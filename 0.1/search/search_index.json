{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"1_basic_sql/","title":"Basic SQL","text":""},{"location":"1_basic_sql/#overview","title":"Overview","text":"<p>Basic SQL Lesson Overview In this lesson, we will cover and you will be able to:</p> <ul> <li>Describe why SQL is important</li> <li>Explain how SQL data is stored and structured</li> <li>Create SQL queries using proper syntax including</li> </ul> <pre><code>SELECT &amp; FROM\nLIMIT\nORDER BY\nWHERE\nBasic arithmetic operations\nLIKE\nIN\nNOT\nAND &amp; BETWEEN &amp; OR\n</code></pre>"},{"location":"1_basic_sql/#entity-relationship-diagram","title":"Entity Relationship Diagram","text":"<p>An entity-relationship diagram (ERD) is a common way to view data in a database. Below is the ERD for the database we will use from Parch &amp; Posey. These diagrams help you visualize the data you are analyzing including:</p> <p>The names of the tables. The columns in each table. The way the tables work together.</p> <p></p> <p>The \"crow's foot\" that connects the tables together shows us how the columns in one table relate to the columns in another table</p>"},{"location":"1_basic_sql/#why-is-sql-important","title":"Why is SQL important","text":"<p>Advantages of using SQL:</p> <ol> <li>SQL is easy to understand</li> <li>Traditional databases allow us to access data directly</li> <li>Traditional databases allow us to audit and replicate our data</li> <li>SQL is great tool for analysing multiple tables at once</li> <li>SQL allows you to analyse more complex questions than dashboards tools like Google Analytics</li> </ol>"},{"location":"1_basic_sql/#advantages-of-sql","title":"Advantages of SQL","text":"<ol> <li>Data integrity is ensured - only data you want to be entered is entered, only authourised users will enter data.</li> <li>Data can be accessed quickly - SQL allows you to obtain results very quickly from the DB. Code can be optimized to pull results quickly.</li> <li>Data is easily shared - multiple users can access data stored in a DB, the data is the same for all users allowing for consistent results for anyone with access to you database.</li> </ol>"},{"location":"1_basic_sql/#sql-vs-no-sql","title":"SQL vs No SQL","text":"<p>These NoSQL environments tend to be particularly popular for web-based data, but less popular for data that lives in spreadsheets the way we have been analyzing data up to this point.</p>"},{"location":"1_basic_sql/#types-of-sql-databases","title":"Types of SQL databases","text":"<ol> <li>MySQL</li> <li>Access</li> <li>Oracle</li> <li>Microsoft SQL Server</li> <li>Postgres</li> </ol> <p>comparison of SQL lite, MYSQL, and PostgreSQL</p>"},{"location":"1_basic_sql/#formatting-sql-queries","title":"Formatting SQL queries","text":"<p>Use Upper and Lower cases in SQL</p> <p>SQL is case insensitive</p> <pre><code>SELECT account_id\nFROM orders\n</code></pre> <p>same as</p> <pre><code>select account_id\nfrom orders\n</code></pre>"},{"location":"1_basic_sql/#best-practices","title":"Best practices","text":"<ol> <li>Capitalize all SQL commands, like <code>SELECT</code> and <code>FROM</code>, and keep everything else in your query lower case</li> <li>Avoid spaces in Table and Variable Names<ul> <li>e.g. Table Name =&gt; table_name</li> </ul> </li> <li>Use white spaces <pre><code>/*good example */\nSELECT account_id FROM orders\n</code></pre> <pre><code>/*bad example */\nSELECT              account_id\n\nFROM               orders\n</code></pre></li> <li>Semicolons depending on your sql environment you may need a semi colon <pre><code>/*with semi colon*/\nSELECT account_id\nFROM orders;\n</code></pre> <pre><code>/*without semi colon*/\nSELECT account_id\nFROM orders\n</code></pre></li> </ol>"},{"location":"1_basic_sql/#sql-clauses","title":"SQL Clauses","text":""},{"location":"1_basic_sql/#limit","title":"LIMIT","text":"<p>The LIMIT statement is useful when you want to see just the first few rows of a table. This can be much faster for loading than if we load the entire dataset.</p> <p>Always used as the last part of query.</p> <pre><code>SELECT *\nFROM orders\nLIMIT 10;\n</code></pre>"},{"location":"1_basic_sql/#order-by","title":"ORDER BY","text":"<p>The ORDER BY statement allows us to sort our results using the data in any column</p> <p>Using ORDER BY in a SQL query only has temporary effects, for the results of that query</p> <ol> <li> <p>First, the query sorts the results in ascending order based on the values in the column specified in the ORDER BY clause.</p> </li> <li> <p>When there are multiple rows with the same value in the specified column, the query then sorts those rows based on the case sensitivity of the characters in the column values. In general, uppercase letters come before lowercase letters in the sort order.</p> </li> <li> <p>When there are still multiple rows with the same value in the specified column and the same case sensitivity, the query then sorts those rows based on the numeric values of the characters in the column values.</p> </li> </ol> <p>For example, if you have a column with the following values: \"B\", \"2\", \"a\", \"1\", \"C\", the order in which the query would sort these values would be: \"1\", \"2\", \"a\", \"B\", \"C\".</p> <p>The ORDER BY statement always comes in a query after the <code>SELECT</code> and <code>FROM</code> statements, but before the <code>LIMIT</code> statement</p> <p>Pro Tip: to order descending use <code>DESC</code> in the  <code>ORDER BY</code> clause </p> <pre><code>SELECT *\nFROM orders\nORDER BY occurred_at\nLIMIT 1000;\n</code></pre> <p>You can <code>ORDER BY</code> more than one column by using a <code>,</code></p> <pre><code>SELECT *\nFROM orders\nORDER BY occurred_at, total_amt_usd DESC\nLIMIT 1000;\n</code></pre> <p>Pro Tip: to remove the case sensitivity when ordering use LOWER or UPPER</p> <pre><code>SELECT *\nFROM orders\nORDER BY LOWER(name)\n</code></pre> <p>Pro Tip: you can use numbers in an <code>ORDER BY</code></p> <pre><code>SELECT name, occurred_at, location\nFROM orders\nORDER BY 2, 3\n</code></pre>"},{"location":"1_basic_sql/#where","title":"WHERE","text":"<p>Using the WHERE statement, we can display subsets of tables based on conditions that must be met. You can also think of the WHERE command as filtering the data.</p> <p>Common symbols used in WHERE statements include:</p> <ul> <li><code>&gt;</code> (greater than)</li> <li><code>&lt;</code> (less than)</li> <li><code>&gt;=</code> (greater than or equal to)</li> <li><code>&lt;=</code> (less than or equal to)</li> <li><code>=</code> (equal to)</li> <li><code>`!=</code> (not equal to)</li> </ul> <pre><code>SELECT *\nFROM orders\nWHERE account_id = 4251\nORDER BY occurred_at\nLIMIT 1000;\n</code></pre>"},{"location":"1_basic_sql/#in","title":"IN","text":"<p>The <code>IN</code> operator is useful for working with both numeric and text columns. This operator allows you to use an =, but for more than one item of that particular column</p> <pre><code>SELECT *\nFROM orders\nWHERE account_id IN (1001,1021);\n</code></pre>"},{"location":"1_basic_sql/#not","title":"NOT","text":"<p>The NOT operator is an extremely useful operator for working with the previous two operators we introduced: <code>IN</code> and <code>LIKE</code>. By specifying <code>NOT LIKE</code> or <code>NOT IN</code>, we can grab all of the rows that do not meet particular criteria.</p> <p>NOT IN example <pre><code>SELECT sales_rep_id, name\nFROM accounts\nWHERE sales_rep_id NOT IN (321500,321570)\nORDER BY sales_rep_id\n</code></pre></p> <p>NOT LIKE example <pre><code>SELECT *\nFROM accounts\nWHERE website NOT LIKE '%com%';\n</code></pre></p>"},{"location":"1_basic_sql/#like","title":"LIKE","text":"<p>The <code>LIKE</code> operator is used to check a specific character or unknown length of characters when searching through text.</p> <p>The <code>pattern</code> can contain two special wildcard characters:</p> <p><code>%</code> - represents any number of characters <code>_</code> - represents a single character</p> <ul> <li>Example 1: Select all the customers whose name starts with the letter 'A' <pre><code>SELECT * FROM customers\nWHERE customer_name LIKE 'A%';\n</code></pre></li> <li>Example 2: Select all the products whose name contains the word 'chocolate' <pre><code>SELECT * FROM products\nWHERE products LIKE '%chocolate%'\n</code></pre></li> <li>Example 3: Select all the orders with order number starting with 'OD' and ending with '8' <pre><code>SELECT *\nFROM products\nWHERE name LIKE 'OD%8'\n</code></pre></li> <li>Example 4: Select all the customers whose name is exactly 5 characters long and ends with 's' <pre><code>SELECT *\nFROM products\nWHERE name LIKE '_____s'\n</code></pre></li> </ul>"},{"location":"1_basic_sql/#logical-operators","title":"Logical Operators","text":""},{"location":"1_basic_sql/#and","title":"AND","text":"<p><code>AND</code> operator is used within the <code>WHERE</code> clause.</p> <p>It is used to combine logical clauses together.</p> <pre><code>WHERE column &gt;= 6 AND column &lt;= 10\n</code></pre>"},{"location":"1_basic_sql/#between","title":"BETWEEN","text":"<p><code>BETWEEN</code> operatoris used for when we want to be between two values</p> <pre><code>WHERE column BETWEEN 6 AND 10\n</code></pre> <p>Pro Tip: for Dates you put the start date and then a day after the end date beacuse the boundary is at 12am</p> <pre><code>/* dates in the year of 2016 */\nSELECT *\nFROM orders\nWHERE occurred_at BETWEEN '2016-01-01' AND '2017-01-01` </code></pre>"},{"location":"2_sql_joins/","title":"SQL JOINs","text":"<p>In this lesson you will be:</p> <ul> <li>Creating Joins</li> <li>Using Primary - Foreign Keys</li> <li>Integrating Aliases</li> <li>Evaluating Various Join Types</li> <li>Integrating Filters with Joins</li> </ul>"},{"location":"2_sql_joins/#why-should-we-split-up-the-data-into-different-tables","title":"Why should we split up the data into different tables","text":"<ol> <li>Easier to organise data into logical tables (content/data management)</li> <li>Optimization of execution<ul> <li>number and type of calculations add to the execution time</li> <li>prevent redundant data if you put the tables all together </li> </ul> </li> </ol>"},{"location":"2_sql_joins/#database-normalization","title":"Database Normalization","text":"<p>Process of organizing a relational database in such a way that it reduces data redundancy and improves data integrity.</p> <p>There are essentially three ideas that are aimed at database normalization:</p> <ul> <li>Are the tables storing logical groupings of the data?</li> <li>Can I make changes in a single location, rather than in many tables for the same information?</li> <li>Can I access and manipulate data quickly and efficiently?</li> </ul>"},{"location":"2_sql_joins/#normal-forms","title":"Normal Forms","text":"<ol> <li> <p>First normal form (1NF): Each table should have a primary key and all columns in the table should be atomic (indivisible).</p> </li> <li> <p>Second normal form (2NF): All non-key attributes should be fully dependent on the primary key.</p> </li> <li> <p>Third normal form (3NF): All non-key attributes should be dependent only on the primary key, and not on any other non-key attributes.</p> </li> </ol> <p>aricle on why we need SQL normalization</p>"},{"location":"2_sql_joins/#joins","title":"JOINs","text":"<p><code>JOIN</code> is a way to combine data from two or more tables. These are usually done through a <code>primary key</code> to a <code>foriegn key</code> but it can be to any columns that have same values.</p>"},{"location":"2_sql_joins/#primary-key","title":"Primary Key","text":"<p>A primary key is a column or a set of columns in a relational database table that uniquely identifies each row in the table</p> <p>It is used to enforce data integrity and ensure that there are no duplicate or null values in the column(s) designated as the <code>primary key</code>.</p> <p>A primary key can be a single column or a combination of columns. When a primary key is defined on multiple columns, it is called a <code>composite primary</code> key</p> <ol> <li>Uniqueness: Each value in the primary key column(s) must be unique.</li> <li>Non-nullability: The primary key column(s) cannot contain null values.</li> <li>Irreducibility: The primary key column(s) must be irreducible, meaning it should not be possible to remove any part of the primary key and still have a unique identifier for each row in the table.</li> </ol>"},{"location":"2_sql_joins/#foreign-key","title":"Foreign Key","text":"<p>In SQL (Structured Query Language), a foreign key is a field or combination of fields in a table that refers to the primary key of another table. It establishes a relationship between two tables by ensuring that the values in the foreign key column(s) of one table match the values in the primary key column(s) of another table.</p>"},{"location":"2_sql_joins/#syntax","title":"Syntax","text":"<p>We use ON clause to specify a JOIN condition which is a logical statement to combine the table in FROM and JOIN statements.</p> <p>Example to get all columns from the tables <code>orders</code> and <code>accounts</code></p> <pre><code>SELECT orders.*,\naccounts.*\nFROM orders JOIN accounts\nON orders.account_id = accounts.id;\n</code></pre> <p>Example to get specific columns from the tables <code>orders</code> and <code>accounts</code></p> <pre><code>SELECT orders.id, orders.total,\naccounts.id\nFROM orders JOIN accounts\nON orders.account_id = accounts.id;\n</code></pre> <p>Example to <code>JOIN</code> multiple tables</p> <p>Provide a table that provides the region for each sales_rep along with their associated accounts. Your final table should include three columns: the region name, the sales rep name, and the account name. Sort the accounts alphabetically (A-Z) according to account name.</p> <pre><code>SELECT r.name region, s.name rep, a.name account\nFROM sales_reps s\nJOIN region r\nON s.region_id = r.id\nJOIN accounts a\nON a.sales_rep_id = s.id\nORDER BY a.name;\n</code></pre>"},{"location":"2_sql_joins/#alias","title":"Alias","text":"<pre><code>Select t1.column1 aliasname, t2.column2 aliasname2\nFROM tablename AS t1\nJOIN tablename2 AS t2\n</code></pre>"},{"location":"2_sql_joins/#types-of-joins","title":"Types of JOINs","text":"<p>If there is not matching information for <code>LEFT</code> and <code>RIGHT</code> <code>JOINS</code> in the JOINed table, then you will have columns with empty cells. These empty cells introduce a new data type called NULL</p> <p>LEFT JOIN <pre><code>SELECT a.id, a.name, o.total\nFROM accounts a\nLEFT JOIN orders o\nON a.id = o.account_id\n</code></pre></p> <p>RIGHT JOIN <pre><code>SELECT a.id, a.name, o.total\nFROM accounts a\nRIGHT JOIN orders o\nON a.id = o.accounts_id\n</code></pre></p> <p>Side Note: These are the same</p> <p><code>LEFT OUTER JOIN</code> and <code>LEFT JOIN</code></p> <p><code>RIGHT OUTER JOIN</code>and <code>RIGHT JOIN</code></p> <p><code>FULL OUTER JOIN</code> and <code>OUTER JOIN</code></p>"},{"location":"3_sql_aggregations/","title":"SQL Aggregations","text":""},{"location":"3_sql_aggregations/#introduction","title":"Introduction","text":"<p>In this lesson, we will cover and you will be able to:</p> <ul> <li>Deal with <code>NULL</code> values</li> <li>Create aggregations in your SQL Queries including</li> <li><code>COUNT</code></li> <li><code>SUM</code></li> <li><code>MIN</code> &amp; <code>MAX</code></li> <li><code>AVG</code></li> <li><code>GROUP BY</code></li> <li><code>DISTINCT</code></li> <li><code>HAVING</code></li> <li>Create <code>DATE</code> functions</li> <li>Implement <code>CASE</code> statements</li> </ul>"},{"location":"3_sql_aggregations/#summary-of-aggregations","title":"Summary of Aggregations","text":"Clause Description Null Treatment Alpha treatement <code>COUNT</code> Counts up all items in a column ignores <code>NULL</code> values Can be used <code>SUM</code> Adds up all numbers in a column ignores <code>NULL</code> values Cannot be used <code>MIN</code> returns the lowest number, earliest date, or non-numerical value as early in the alphabet as possible (a- Z) ignores <code>NULL</code> values Can be used <code>MAX</code> returns the highest number, earliest date, or non-numerical value as early in the alphabet as possible (Z- a) ignores <code>NULL</code> values Can be used <code>AVG</code> returns the mean of the data ignores <code>NULL</code> values Cannot be used"},{"location":"3_sql_aggregations/#null","title":"NULL","text":"<p>Datatype that specifiies that there is no data exists i.e. it does not necessarily mean 0 it is the absence of data.</p> <p>Protip We don't use =, because NULL isn't considered a value in SQL. Rather, it is a property of the data.</p> <p>Filtering for <code>NULL</code></p> <pre><code>SELECT *\nFROM table\nWHERE col_1 IS NULL\n</code></pre> <p>Filtering for <code>NOT NULL</code> <pre><code>SELECT *\nFROM table\nWHERE col_1 IS NOT NULL\n</code></pre></p>"},{"location":"3_sql_aggregations/#aggregations","title":"Aggregations","text":""},{"location":"3_sql_aggregations/#count","title":"COUNT","text":"<p><code>COUNT</code> over all rows in a table</p> <pre><code>SELECT COUNT(*)\nFROM accounts;\n</code></pre> <p><code>COUNT</code> over speciic column (this will count only non <code>NULL</code> values)</p> <pre><code>SELECT COUNT(accounts.id)\nFROM accounts;\n</code></pre>"},{"location":"3_sql_aggregations/#sum","title":"SUM","text":"<pre><code>SELECT SUM(standard_qty) AS standard,\nSUM(gloss_qty) AS gloss,\nSUM(poster_qty) AS poster\nFROM orders\n</code></pre>"},{"location":"3_sql_aggregations/#min-and-max","title":"MIN and MAX","text":"<pre><code>SELECT MIN(standard_qty) AS standard_min,\nMIN(gloss_qty) AS gloss_min,\nMIN(poster_qty) AS poster_min,\nMAX(standard_qty) AS standard_max,\nMAX(gloss_qty) AS gloss_max,\nMAX(poster_qty) AS poster_max\nFROM   orders\n</code></pre>"},{"location":"3_sql_aggregations/#avg","title":"AVG","text":"<pre><code>SELECT AVG(standard_qty) AS standard_avg,\nAVG(gloss_qty) AS gloss_avg,\nAVG(poster_qty) AS poster_avg\nFROM orders\n</code></pre> <p><code>AVG</code> when you want to include NULLs as 0</p> <ul> <li>Use the <code>COALESCE</code> function</li> </ul> <pre><code>SELECT AVG(COALESCE(amount, 0)) AS average_amount\nFROM table\n</code></pre> <p>The innermost subquery retrieves the column_name values, assigns a unique row_num to each row using the ROW_NUMBER() function, and calculates the total number of rows in the table using the COUNT(*) OVER() function.</p> <pre><code>/* output of subquery */\n+-----------+--------+------------+\n| column_name | row_num | total_rows |\n+-----------+--------+------------+\n| 50.00 |      5 |         10 |\n| 60.00 |      6 |         10 |\n+-----------+--------+------------+\n</code></pre> <p>The middle subquery filters the rows that have a row_num equal to either FLOOR((total_rows + 1) / 2.0) or CEILING((total_rows + 1) / 2.0).</p> <p>If the number of rows in the table is odd, FLOOR((total_rows + 1) / 2.0) returns the exact middle row number, and the WHERE clause selects that row.</p> <p>If the number of rows in the table is even, FLOOR((total_rows + 1) / 2.0) and CEILING((total_rows + 1) / 2.0) return the two middle row numbers, and the WHERE clause selects those two rows.</p> <p>The outermost query calculates the median by taking the AVG() of the selected rows.</p> <p>In this case, since the sales table has an even number of rows, the middle subquery selects rows 5 and 6 with sales amounts of 50.00 and 60.00.</p>"},{"location":"3_sql_aggregations/#median-no-function-out-the-box","title":"Median (no function out the box)","text":"<p><code>MEDIAN</code> is more advanced to calculate</p> <pre><code>SELECT column_name, row_num, total_rows\nFROM (\nSELECT column_name, ROW_NUMBER() OVER (ORDER BY column_name) AS row_num, COUNT(*) OVER () AS total_rows\nFROM sales\n) subquery\nWHERE row_num = FLOOR((total_rows + 1) / 2.0) OR row_num = CEILING((total_rows + 1) / 2.0);\n</code></pre>"},{"location":"3_sql_aggregations/#group-by","title":"GROUP BY","text":"<ul> <li>Used to aggregate subsets of data e.g. by region, age, gender</li> <li>Any column not in the <code>SELECT</code> statement that is not within an aggregator must be in the <code>GROUP BY</code> clause</li> <li>Goes between <code>WHERE</code> and <code>ORDER BY</code> <pre><code>SELECT col1, col2, SUM(col2) total\nFROM table\nWHERE col2 = 'M'\nGROUP BY col1\nORDER BY total\n</code></pre></li> <li><code>ORDER BY</code> is temporary and will not change the table</li> <li>Evaluated before the <code>LIMIT</code> so all aggregations will be performed so there are no errors, but that means that if you are using <code>LIMIT</code> for performance reasons you won't get any benefit <pre><code>/* if you want a performance benefit use a subquery */\nSELECT col1, col2, SUM(col2) total\nFROM (SELECT * FROM table LIMIT 100) as t1\nWHERE col2 = 'M'\nGROUP BY col1\nORDER BY total\n</code></pre></li> <li>You can <code>GROUP BY</code> multiple columns at once<ul> <li>order of the columns in the <code>ORDER BY</code> does not matter</li> <li>you can subsitute numbers for columns</li> </ul> </li> </ul>"},{"location":"3_sql_aggregations/#distinct","title":"DISTINCT","text":"<ul> <li>Provides unique rows for all columns</li> <li><code>DISTINCT</code> is always used in <code>SELECT</code> statements</li> <li>Only use <code>DISTINCT</code> once<ul> <li>Correct <pre><code>SELECT DISTINCT column1, column2\nFROM table\n</code></pre></li> <li>Wrong! <pre><code>SELECT DISTINCT column1, DISTINCT column2 /* do not do this */\nFROM table\n</code></pre></li> </ul> </li> </ul> <p>Case study</p> <p>Example data</p> sale_id customer_name product_name sale_date 1 John T-shirt 2022-01-01 2 John T-shirt 2022-01-03 3 Sarah Hoodie 2022-01-02 4 Jane Jeans 2022-01-04 5 Jane Jeans 2022-01-05 6 John Jeans 2022-01-03 7 Sarah T-shirt 2022-01-04 8 Jane Hoodie 2022-01-05 <p>Distinct on one column</p> <pre><code>SELECT DISTINCT customer_name\nFROM sales;\n</code></pre> <p>Output</p> customer_name John Sarah Jane <p>Distinct on two columns</p> <pre><code>SELECT DISTINCT customer_name, product_name\nFROM sales;\n</code></pre> customer_name product_name John T-shirt Sarah Hoodie Jane Jeans John Jeans Sarah T-shirt Jane Hoodie <p>Using Distinct with aggregations</p> <pre><code>SELECT COUNT(DISTINCT customer_name), COUNT(DISTINCT product_name)\nFROM orders </code></pre> <p>output</p> COUNT(DISTINCT customer_name) COUNT(DISTINCT product_name) 3 3"},{"location":"3_sql_aggregations/#having","title":"HAVING","text":"<ul> <li>Filtering a query that has aggregations</li> <li>Anytime you want to perform a <code>WHERE</code> on an aggregation you must use  <code>HAVING</code></li> </ul> WHERE HAVING <code>WHERE</code> subsets the returned data based on logical condition works on logical statements involving aggregations appears after the <code>FROM</code>, <code>JOIN</code> and <code>ON</code> but before <code>GROUP BY</code> appears after the <code>GROUP BY</code> but before <code>ORDER BY</code> <p>simple example</p> <pre><code>SELECT account_id,\nSUM(total_amt_usd) AS sum_total_amt_usd\nFROM orders\nGROUP BY 1\nHAVING SUM(total_amt_usd) &gt;= 250000\n</code></pre> <p>example of <code>WHERE</code> and <code>HAVING</code></p> <pre><code>SELECT customer_id, COUNT(*) as num_orders, SUM(order_total) as total_sales\nFROM orders\nWHERE order_date BETWEEN '2022-01-01' AND '2022-12-31' -- Only orders in 2022\nGROUP BY customer_id\nHAVING COUNT(*) &gt; 5 AND SUM(order_total) &gt; 1000\nORDER BY total_sales\n</code></pre>"},{"location":"3_sql_aggregations/#date-functions","title":"DATE FUNCTIONS","text":"<p>Database format <code>YYYY MM DD</code> - dates sorted alphabetically are in chronological order</p>"},{"location":"3_sql_aggregations/#date_trunc","title":"DATE_TRUNC","text":"<ul> <li>truncates the date to the required position</li> <li>syntax     <pre><code>DATE_TRUNC('&lt;date option e.g. day&gt;', column_name)\n</code></pre></li> <li>options<ul> <li><code>day</code></li> <li><code>month</code></li> <li><code>year</code></li> </ul> </li> </ul> <p>example to groupby the year <pre><code> SELECT DATE_FUNC('year', occurred_at) ord_year,  SUM(total_amt_usd) total_spent\nFROM orders\nGROUP BY 1\nORDER BY 2 DESC;\n</code></pre></p>"},{"location":"3_sql_aggregations/#date_part","title":"DATE_PART","text":"<ul> <li>extracts only that part of the <code>DATE</code> e.g. the month</li> <li>syntax     <pre><code>DATE_PART('&lt;date option e.g. day&gt;', column_name)\n</code></pre></li> <li>options<ul> <li><code>dow</code> i.e. day of week</li> <li><code>day</code></li> <li><code>month</code></li> <li><code>year</code></li> </ul> </li> </ul> <p>Example for month from any year</p> <pre><code>SELECT DATE_PART('month', occurred_at) ord_month, SUM(total_amt_usd) total_spent\nFROM orders\nWHERE occurred_at BETWEEN '2014-01-01' AND '2017-01-01'\nGROUP BY 1\nORDER BY 2 DESC; </code></pre>"},{"location":"3_sql_aggregations/#case","title":"CASE","text":"<ul> <li>The CASE statement always goes in the SELECT clause.</li> <li>CASE must include the following components: WHEN, THEN, and END. ELSE is an optional component to catch cases that didn\u2019t meet any of the other previous CASE conditions.</li> <li>You can make any conditional statement using any conditional operator (like WHERE) between WHEN and THEN. This includes stringing together multiple conditional statements using AND and OR.</li> <li>You can include multiple WHEN statements, as well as an ELSE statement again, to deal with any unaddressed conditions.</li> </ul> <pre><code>SELECT account_id, CASE WHEN standard_qty = 0 OR standard_qty IS NULL THEN 0\nELSE standard_amt_usd/standard_qty END AS unit_price\nFROM orders\nLIMIT 10;\n</code></pre> <pre><code>SELECT account_id,\noccurred_at,\ntotal,\nCASE WHEN total &gt; 500 THEN 'Over 500'\nWHEN total &gt; 300 THEN '301 - 500'\nWHEN total &gt; 100 THEN '101 - 300'\nELSE '100 or under' END AS total_group\nFROM orders\n</code></pre>"},{"location":"4_sql_sub_queries_temp_tables/","title":"Sub queries and Temp tables","text":"<p>Subquery: a query that runs within an outer query</p> <p></p> <pre><code>SELECT product_id,\nname,\nprice\nFROM db.product\nWhere price &gt; (SELECT AVG(price) FROM db.product) -- right part is subquery\n</code></pre>"},{"location":"4_sql_sub_queries_temp_tables/#when-do-you-need-a-subquery","title":"When do you need a subquery?","text":"<ul> <li>manipulating an existing table to \"pseudo-create\" a table which is used as part of a larger query</li> </ul> <p>Example of when to use subqueries</p> <ul> <li>Identify the top-selling Amazon products in months where sales have exceeded $1m<ul> <li>Existing Table: Amazon daily sales</li> <li>Subquery Aggregation: Daily to Monthly</li> </ul> </li> <li>Examine the average price of a brand\u2019s products for the highest-grossing brands<ul> <li>Existing Table: Product pricing data across all retailers</li> <li>Subquery Aggregation: Individual to Average</li> </ul> </li> <li>Order the annual salary of employees that are working less than 150 hours a month<ul> <li>Existing Table: Daily time-table of employees</li> <li>Subquery Aggregation: Daily to Monthly</li> </ul> </li> </ul>"},{"location":"4_sql_sub_queries_temp_tables/#subqueries-vs-joins","title":"Subqueries VS JOINs","text":"Factor Subquery Join Use cases When an existing table needs to be manipulated or aggregated to then be joined to a larger table. A fully flexible and discretionary use case where a user wants to bring two or more tables together and select and filter as needed. Syntax A subquery is a query within a query. The syntax, as a result, has multiple SELECT and FROM clauses. A join is simple stitching together multiple tables with a common key or column. A join clause cannot stand and be run independently Dependencies A subquery clause can be run completely independently. When trying to debug code, subqueries are often run independently to pressure test results before running the larger query. A join clause cannot stand and be run independently. Output Both subqueries and joins are essentially bringing multiple tables together (whether an existing table is first manipulated or not) to generate a single output. Same as previous cell to the left Deep Dive Topics What happens under the hood: Query plans are similar for both subqueries and joins, read this link Same as previous cell to the left"},{"location":"4_sql_sub_queries_temp_tables/#subquery-basics","title":"Subquery Basics","text":"<ul> <li>Must be fully placed inside paranthesis</li> <li>Must be fully independent and can be executed on their own (except Correlated subqueries)</li> <li>Two components of subqueries<ol> <li>Placement - Where it is placed<ul> <li>With<ul> <li>also known as a common table expression (CTE)</li> <li>allows you to define a temporary named result set that can be referenced multiple times within a larger query</li> <li>common use case is to simplify complex queries or create a temp table with limited rows to improve performance <pre><code>WITH top_paid_employees AS (\nSELECT employee_id, first_name, last_name, salary\nFROM employees\nORDER BY salary DESC\nLIMIT 10\n)\nSELECT e.employee_id, e.first_name, e.last_name, e.department_id, tpe.salary\nFROM employees e\nJOIN top_paid_employees tpe\nON e.employee_id = tpe.employee_id;\n</code></pre></li> </ul> </li> <li>Nested<ul> <li>A nested subquery is a subquery that is embedded within another subquery or the main query <pre><code>SELECT department_name\nFROM departments d\nWHERE department_id IN (\nSELECT department_id\nFROM employees\nGROUP BY department_id\nHAVING COUNT(*) &gt; 5\n);\n</code></pre></li> </ul> </li> <li>Inline<ul> <li>This subquery is used in the same fashion as the WITH use case above. However, instead of the temporary table sitting on top of the larger query, it\u2019s embedded within the from clause. <pre><code>SELECT student_name\nFROM\n(SELECT student_id, student_name, grade\nFROM student\nWHERE teacher =10)\nWHERE grade &gt;80;\n</code></pre></li> </ul> </li> <li>Scalar<ul> <li>A scalar subquery is a subquery that returns a single value, which can be used as part of an expression in the main query <pre><code>SELECT employee_id, first_name, last_name, salary,\n(SELECT MIN(salary) FROM employees) AS min_salary\nFROM employees;\n</code></pre></li> </ul> </li> </ul> </li> <li>Dependencies - with the outer/larger query<ul> <li>Simple - The inner subquery is completely independent of the larger query.</li> <li>example 1 <pre><code>WITH dept_average AS (SELECT dept, AVG(salary) AS avg_dept_salary\nFROM employee\nGROUP BY employee.dept\n)\nSELECT E.eid, E.ename, D.avg_dept_salary\nFROM employee E\nJOIN dept.average D\nON E.dept = D.dept\nWHERE E.salary &gt; D.avg_dept_salary\n</code></pre></li> <li>Correlated - The inner subquery is dependent on the larger query.</li> <li>example 1 <pre><code>SELECT employee_id, name\nFROM employees_db emp\nWHERE salary &gt; (SELECT AVG(salary)\nFROM employees_db\nWHERE department = emp.department\n);\n</code></pre></li> <li>example 1 (pretty sure you can do this with a groupby) <pre><code>SELECT first_name, last_name, (\nSELECT AVG(GPA)\nFROM outer_db\nWHERE university = outer_db.university) GPA, university\nFROM student_db outer_db;\n</code></pre></li> <li>example 2 <pre><code>SELECT first_name, last_name, GPA, university\nFROM student_db outer_db\nWHERE GPA &gt;\n(SELECT AVG(GPA)\nFROM student_db\nWHERE university = outer_db.university);\n</code></pre></li> </ul> </li> </ol> </li> </ul>"}]}