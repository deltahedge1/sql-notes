{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to my SQL notes These notes relate to the sql challenge on Udacity Dedicate this site to El Chapo for making sure we lose every game so that I can get off and study","title":"homepage"},{"location":"#welcome-to-my-sql-notes","text":"These notes relate to the sql challenge on Udacity Dedicate this site to El Chapo for making sure we lose every game so that I can get off and study","title":"Welcome to my SQL notes"},{"location":"1_basic_sql/","text":"Basic SQL Overview Basic SQL Lesson Overview In this lesson, we will cover and you will be able to: Describe why SQL is important Explain how SQL data is stored and structured Create SQL queries using proper syntax including SELECT & FROM LIMIT ORDER BY WHERE Basic arithmetic operations LIKE IN NOT AND & BETWEEN & OR Entity Relationship Diagram An entity-relationship diagram (ERD) is a common way to view data in a database. Below is the ERD for the database we will use from Parch & Posey. These diagrams help you visualize the data you are analyzing including: The names of the tables. The columns in each table. The way the tables work together. The \"crow's foot\" that connects the tables together shows us how the columns in one table relate to the columns in another table Why is SQL important Advantages of using SQL: SQL is easy to understand Traditional databases allow us to access data directly Traditional databases allow us to audit and replicate our data SQL is great tool for analysing multiple tables at once SQL allows you to analyse more complex questions than dashboards tools like Google Analytics Advantages of SQL Data integrity is ensured - only data you want to be entered is entered, only authourised users will enter data. Data can be accessed quickly - SQL allows you to obtain results very quickly from the DB. Code can be optimized to pull results quickly. Data is easily shared - multiple users can access data stored in a DB, the data is the same for all users allowing for consistent results for anyone with access to you database. SQL vs No SQL These NoSQL environments tend to be particularly popular for web-based data, but less popular for data that lives in spreadsheets the way we have been analyzing data up to this point. Types of SQL databases MySQL Access Oracle Microsoft SQL Server Postgres comparison of SQL lite, MYSQL, and PostgreSQL Formatting SQL queries Use Upper and Lower cases in SQL SQL is case insensitive SELECT account_id FROM orders same as select account_id from orders Best practices Capitalize all SQL commands, like SELECT and FROM , and keep everything else in your query lower case Avoid spaces in Table and Variable Names e.g. Table Name => table_name Use white spaces /*good example */ SELECT account_id FROM orders /*bad example */ SELECT account_id FROM orders Semicolons depending on your sql environment you may need a semi colon /*with semi colon*/ SELECT account_id FROM orders ; /*without semi colon*/ SELECT account_id FROM orders SQL Clauses LIMIT The LIMIT statement is useful when you want to see just the first few rows of a table. This can be much faster for loading than if we load the entire dataset. Always used as the last part of query. SELECT * FROM orders LIMIT 10 ; ORDER BY The ORDER BY statement allows us to sort our results using the data in any column Using ORDER BY in a SQL query only has temporary effects, for the results of that query First, the query sorts the results in ascending order based on the values in the column specified in the ORDER BY clause. When there are multiple rows with the same value in the specified column, the query then sorts those rows based on the case sensitivity of the characters in the column values. In general, uppercase letters come before lowercase letters in the sort order. When there are still multiple rows with the same value in the specified column and the same case sensitivity, the query then sorts those rows based on the numeric values of the characters in the column values. For example, if you have a column with the following values: \"B\", \"2\", \"a\", \"1\", \"C\", the order in which the query would sort these values would be: \"1\", \"2\", \"a\", \"B\", \"C\". The ORDER BY statement always comes in a query after the SELECT and FROM statements, but before the LIMIT statement Pro Tip : to order descending use DESC in the ORDER BY clause SELECT * FROM orders ORDER BY occurred_at LIMIT 1000 ; You can ORDER BY more than one column by using a , SELECT * FROM orders ORDER BY occurred_at , total_amt_usd DESC LIMIT 1000 ; Pro Tip : to remove the case sensitivity when ordering use LOWER or UPPER SELECT * FROM orders ORDER BY LOWER ( name ) Pro Tip : you can use numbers in an ORDER BY SELECT name , occurred_at , location FROM orders ORDER BY 2 , 3 WHERE Using the WHERE statement, we can display subsets of tables based on conditions that must be met. You can also think of the WHERE command as filtering the data. Common symbols used in WHERE statements include: > (greater than) < (less than) >= (greater than or equal to) <= (less than or equal to) = (equal to) `!= (not equal to) SELECT * FROM orders WHERE account_id = 4251 ORDER BY occurred_at LIMIT 1000 ; IN The IN operator is useful for working with both numeric and text columns. This operator allows you to use an =, but for more than one item of that particular column SELECT * FROM orders WHERE account_id IN ( 1001 , 1021 ); NOT The NOT operator is an extremely useful operator for working with the previous two operators we introduced: IN and LIKE . By specifying NOT LIKE or NOT IN , we can grab all of the rows that do not meet particular criteria. NOT IN example SELECT sales_rep_id , name FROM accounts WHERE sales_rep_id NOT IN ( 321500 , 321570 ) ORDER BY sales_rep_id NOT LIKE example SELECT * FROM accounts WHERE website NOT LIKE '%com%' ; LIKE The LIKE operator is used to check a specific character or unknown length of characters when searching through text. The pattern can contain two special wildcard characters: % - represents any number of characters _ - represents a single character Example 1: Select all the customers whose name starts with the letter 'A' SELECT * FROM customers WHERE customer_name LIKE 'A%' ; Example 2: Select all the products whose name contains the word 'chocolate' SELECT * FROM products WHERE products LIKE '%chocolate%' Example 3: Select all the orders with order number starting with 'OD' and ending with '8' SELECT * FROM products WHERE name LIKE 'OD%8' Example 4: Select all the customers whose name is exactly 5 characters long and ends with 's' SELECT * FROM products WHERE name LIKE '_____s' Logical Operators AND AND operator is used within the WHERE clause. It is used to combine logical clauses together. WHERE column >= 6 AND column <= 10 BETWEEN BETWEEN operatoris used for when we want to be between two values WHERE column BETWEEN 6 AND 10 Pro Tip : for Dates you put the start date and then a day after the end date beacuse the boundary is at 12am /* dates in the year of 2016 */ SELECT * FROM orders WHERE occurred_at BETWEEN '2016-01-01' AND ' 2017 - 01 - 01 `","title":"Basic SQL"},{"location":"1_basic_sql/#basic-sql","text":"","title":"Basic SQL"},{"location":"1_basic_sql/#overview","text":"Basic SQL Lesson Overview In this lesson, we will cover and you will be able to: Describe why SQL is important Explain how SQL data is stored and structured Create SQL queries using proper syntax including SELECT & FROM LIMIT ORDER BY WHERE Basic arithmetic operations LIKE IN NOT AND & BETWEEN & OR","title":"Overview"},{"location":"1_basic_sql/#entity-relationship-diagram","text":"An entity-relationship diagram (ERD) is a common way to view data in a database. Below is the ERD for the database we will use from Parch & Posey. These diagrams help you visualize the data you are analyzing including: The names of the tables. The columns in each table. The way the tables work together. The \"crow's foot\" that connects the tables together shows us how the columns in one table relate to the columns in another table","title":"Entity Relationship Diagram"},{"location":"1_basic_sql/#why-is-sql-important","text":"Advantages of using SQL: SQL is easy to understand Traditional databases allow us to access data directly Traditional databases allow us to audit and replicate our data SQL is great tool for analysing multiple tables at once SQL allows you to analyse more complex questions than dashboards tools like Google Analytics","title":"Why is SQL important"},{"location":"1_basic_sql/#advantages-of-sql","text":"Data integrity is ensured - only data you want to be entered is entered, only authourised users will enter data. Data can be accessed quickly - SQL allows you to obtain results very quickly from the DB. Code can be optimized to pull results quickly. Data is easily shared - multiple users can access data stored in a DB, the data is the same for all users allowing for consistent results for anyone with access to you database.","title":"Advantages of SQL"},{"location":"1_basic_sql/#sql-vs-no-sql","text":"These NoSQL environments tend to be particularly popular for web-based data, but less popular for data that lives in spreadsheets the way we have been analyzing data up to this point.","title":"SQL vs No SQL"},{"location":"1_basic_sql/#types-of-sql-databases","text":"MySQL Access Oracle Microsoft SQL Server Postgres comparison of SQL lite, MYSQL, and PostgreSQL","title":"Types of SQL databases"},{"location":"1_basic_sql/#formatting-sql-queries","text":"Use Upper and Lower cases in SQL SQL is case insensitive SELECT account_id FROM orders same as select account_id from orders","title":"Formatting SQL queries"},{"location":"1_basic_sql/#best-practices","text":"Capitalize all SQL commands, like SELECT and FROM , and keep everything else in your query lower case Avoid spaces in Table and Variable Names e.g. Table Name => table_name Use white spaces /*good example */ SELECT account_id FROM orders /*bad example */ SELECT account_id FROM orders Semicolons depending on your sql environment you may need a semi colon /*with semi colon*/ SELECT account_id FROM orders ; /*without semi colon*/ SELECT account_id FROM orders","title":"Best practices"},{"location":"1_basic_sql/#sql-clauses","text":"","title":"SQL Clauses"},{"location":"1_basic_sql/#limit","text":"The LIMIT statement is useful when you want to see just the first few rows of a table. This can be much faster for loading than if we load the entire dataset. Always used as the last part of query. SELECT * FROM orders LIMIT 10 ;","title":"LIMIT"},{"location":"1_basic_sql/#order-by","text":"The ORDER BY statement allows us to sort our results using the data in any column Using ORDER BY in a SQL query only has temporary effects, for the results of that query First, the query sorts the results in ascending order based on the values in the column specified in the ORDER BY clause. When there are multiple rows with the same value in the specified column, the query then sorts those rows based on the case sensitivity of the characters in the column values. In general, uppercase letters come before lowercase letters in the sort order. When there are still multiple rows with the same value in the specified column and the same case sensitivity, the query then sorts those rows based on the numeric values of the characters in the column values. For example, if you have a column with the following values: \"B\", \"2\", \"a\", \"1\", \"C\", the order in which the query would sort these values would be: \"1\", \"2\", \"a\", \"B\", \"C\". The ORDER BY statement always comes in a query after the SELECT and FROM statements, but before the LIMIT statement Pro Tip : to order descending use DESC in the ORDER BY clause SELECT * FROM orders ORDER BY occurred_at LIMIT 1000 ; You can ORDER BY more than one column by using a , SELECT * FROM orders ORDER BY occurred_at , total_amt_usd DESC LIMIT 1000 ; Pro Tip : to remove the case sensitivity when ordering use LOWER or UPPER SELECT * FROM orders ORDER BY LOWER ( name ) Pro Tip : you can use numbers in an ORDER BY SELECT name , occurred_at , location FROM orders ORDER BY 2 , 3","title":"ORDER BY"},{"location":"1_basic_sql/#where","text":"Using the WHERE statement, we can display subsets of tables based on conditions that must be met. You can also think of the WHERE command as filtering the data. Common symbols used in WHERE statements include: > (greater than) < (less than) >= (greater than or equal to) <= (less than or equal to) = (equal to) `!= (not equal to) SELECT * FROM orders WHERE account_id = 4251 ORDER BY occurred_at LIMIT 1000 ;","title":"WHERE"},{"location":"1_basic_sql/#in","text":"The IN operator is useful for working with both numeric and text columns. This operator allows you to use an =, but for more than one item of that particular column SELECT * FROM orders WHERE account_id IN ( 1001 , 1021 );","title":"IN"},{"location":"1_basic_sql/#not","text":"The NOT operator is an extremely useful operator for working with the previous two operators we introduced: IN and LIKE . By specifying NOT LIKE or NOT IN , we can grab all of the rows that do not meet particular criteria. NOT IN example SELECT sales_rep_id , name FROM accounts WHERE sales_rep_id NOT IN ( 321500 , 321570 ) ORDER BY sales_rep_id NOT LIKE example SELECT * FROM accounts WHERE website NOT LIKE '%com%' ;","title":"NOT"},{"location":"1_basic_sql/#like","text":"The LIKE operator is used to check a specific character or unknown length of characters when searching through text. The pattern can contain two special wildcard characters: % - represents any number of characters _ - represents a single character Example 1: Select all the customers whose name starts with the letter 'A' SELECT * FROM customers WHERE customer_name LIKE 'A%' ; Example 2: Select all the products whose name contains the word 'chocolate' SELECT * FROM products WHERE products LIKE '%chocolate%' Example 3: Select all the orders with order number starting with 'OD' and ending with '8' SELECT * FROM products WHERE name LIKE 'OD%8' Example 4: Select all the customers whose name is exactly 5 characters long and ends with 's' SELECT * FROM products WHERE name LIKE '_____s'","title":"LIKE"},{"location":"1_basic_sql/#logical-operators","text":"","title":"Logical Operators"},{"location":"1_basic_sql/#and","text":"AND operator is used within the WHERE clause. It is used to combine logical clauses together. WHERE column >= 6 AND column <= 10","title":"AND"},{"location":"1_basic_sql/#between","text":"BETWEEN operatoris used for when we want to be between two values WHERE column BETWEEN 6 AND 10 Pro Tip : for Dates you put the start date and then a day after the end date beacuse the boundary is at 12am /* dates in the year of 2016 */ SELECT * FROM orders WHERE occurred_at BETWEEN '2016-01-01' AND ' 2017 - 01 - 01 `","title":"BETWEEN"},{"location":"2_sql_joins/","text":"SQL JOINs In this lesson you will be: Creating Joins Using Primary - Foreign Keys Integrating Aliases Evaluating Various Join Types Integrating Filters with Joins Why should we split up the data into different tables Easier to organise data into logical tables (content/data management) Optimization of execution number and type of calculations add to the execution time prevent redundant data if you put the tables all together Database Normalization Process of organizing a relational database in such a way that it reduces data redundancy and improves data integrity. There are essentially three ideas that are aimed at database normalization: Are the tables storing logical groupings of the data? Can I make changes in a single location, rather than in many tables for the same information? Can I access and manipulate data quickly and efficiently? Normal Forms First normal form (1NF): Each table should have a primary key and all columns in the table should be atomic (indivisible). Second normal form (2NF): All non-key attributes should be fully dependent on the primary key. Third normal form (3NF): All non-key attributes should be dependent only on the primary key, and not on any other non-key attributes. aricle on why we need SQL normalization JOINs JOIN is a way to combine data from two or more tables. These are usually done through a primary key to a foriegn key but it can be to any columns that have same values. Primary Key A primary key is a column or a set of columns in a relational database table that uniquely identifies each row in the table It is used to enforce data integrity and ensure that there are no duplicate or null values in the column(s) designated as the primary key . A primary key can be a single column or a combination of columns. When a primary key is defined on multiple columns, it is called a composite primary key Uniqueness: Each value in the primary key column(s) must be unique. Non-nullability: The primary key column(s) cannot contain null values. Irreducibility: The primary key column(s) must be irreducible, meaning it should not be possible to remove any part of the primary key and still have a unique identifier for each row in the table. Foreign Key In SQL (Structured Query Language), a foreign key is a field or combination of fields in a table that refers to the primary key of another table. It establishes a relationship between two tables by ensuring that the values in the foreign key column(s) of one table match the values in the primary key column(s) of another table. Syntax We use ON clause to specify a JOIN condition which is a logical statement to combine the table in FROM and JOIN statements. Example to get all columns from the tables orders and accounts SELECT orders . * , accounts . * FROM orders JOIN accounts ON orders . account_id = accounts . id ; Example to get specific columns from the tables orders and accounts SELECT orders . id , orders . total , accounts . id FROM orders JOIN accounts ON orders . account_id = accounts . id ; Example to JOIN multiple tables Provide a table that provides the region for each sales_rep along with their associated accounts. Your final table should include three columns: the region name, the sales rep name, and the account name. Sort the accounts alphabetically (A-Z) according to account name. SELECT r . name region , s . name rep , a . name account FROM sales_reps s JOIN region r ON s . region_id = r . id JOIN accounts a ON a . sales_rep_id = s . id ORDER BY a . name ; Alias Select t1 . column1 aliasname , t2 . column2 aliasname2 FROM tablename AS t1 JOIN tablename2 AS t2 Types of JOINs If there is not matching information for LEFT and RIGHT JOINS in the JOINed table, then you will have columns with empty cells. These empty cells introduce a new data type called NULL LEFT JOIN SELECT a . id , a . name , o . total FROM accounts a LEFT JOIN orders o ON a . id = o . account_id RIGHT JOIN SELECT a . id , a . name , o . total FROM accounts a RIGHT JOIN orders o ON a . id = o . accounts_id Side Note: These are the same LEFT OUTER JOIN and LEFT JOIN RIGHT OUTER JOIN and RIGHT JOIN FULL OUTER JOIN and OUTER JOIN","title":"SQL JOINs"},{"location":"2_sql_joins/#sql-joins","text":"In this lesson you will be: Creating Joins Using Primary - Foreign Keys Integrating Aliases Evaluating Various Join Types Integrating Filters with Joins","title":"SQL JOINs"},{"location":"2_sql_joins/#why-should-we-split-up-the-data-into-different-tables","text":"Easier to organise data into logical tables (content/data management) Optimization of execution number and type of calculations add to the execution time prevent redundant data if you put the tables all together","title":"Why should we split up the data into different tables"},{"location":"2_sql_joins/#database-normalization","text":"Process of organizing a relational database in such a way that it reduces data redundancy and improves data integrity. There are essentially three ideas that are aimed at database normalization: Are the tables storing logical groupings of the data? Can I make changes in a single location, rather than in many tables for the same information? Can I access and manipulate data quickly and efficiently?","title":"Database Normalization"},{"location":"2_sql_joins/#normal-forms","text":"First normal form (1NF): Each table should have a primary key and all columns in the table should be atomic (indivisible). Second normal form (2NF): All non-key attributes should be fully dependent on the primary key. Third normal form (3NF): All non-key attributes should be dependent only on the primary key, and not on any other non-key attributes. aricle on why we need SQL normalization","title":"Normal Forms"},{"location":"2_sql_joins/#joins","text":"JOIN is a way to combine data from two or more tables. These are usually done through a primary key to a foriegn key but it can be to any columns that have same values.","title":"JOINs"},{"location":"2_sql_joins/#primary-key","text":"A primary key is a column or a set of columns in a relational database table that uniquely identifies each row in the table It is used to enforce data integrity and ensure that there are no duplicate or null values in the column(s) designated as the primary key . A primary key can be a single column or a combination of columns. When a primary key is defined on multiple columns, it is called a composite primary key Uniqueness: Each value in the primary key column(s) must be unique. Non-nullability: The primary key column(s) cannot contain null values. Irreducibility: The primary key column(s) must be irreducible, meaning it should not be possible to remove any part of the primary key and still have a unique identifier for each row in the table.","title":"Primary Key"},{"location":"2_sql_joins/#foreign-key","text":"In SQL (Structured Query Language), a foreign key is a field or combination of fields in a table that refers to the primary key of another table. It establishes a relationship between two tables by ensuring that the values in the foreign key column(s) of one table match the values in the primary key column(s) of another table.","title":"Foreign Key"},{"location":"2_sql_joins/#syntax","text":"We use ON clause to specify a JOIN condition which is a logical statement to combine the table in FROM and JOIN statements. Example to get all columns from the tables orders and accounts SELECT orders . * , accounts . * FROM orders JOIN accounts ON orders . account_id = accounts . id ; Example to get specific columns from the tables orders and accounts SELECT orders . id , orders . total , accounts . id FROM orders JOIN accounts ON orders . account_id = accounts . id ; Example to JOIN multiple tables Provide a table that provides the region for each sales_rep along with their associated accounts. Your final table should include three columns: the region name, the sales rep name, and the account name. Sort the accounts alphabetically (A-Z) according to account name. SELECT r . name region , s . name rep , a . name account FROM sales_reps s JOIN region r ON s . region_id = r . id JOIN accounts a ON a . sales_rep_id = s . id ORDER BY a . name ;","title":"Syntax"},{"location":"2_sql_joins/#alias","text":"Select t1 . column1 aliasname , t2 . column2 aliasname2 FROM tablename AS t1 JOIN tablename2 AS t2","title":"Alias"},{"location":"2_sql_joins/#types-of-joins","text":"If there is not matching information for LEFT and RIGHT JOINS in the JOINed table, then you will have columns with empty cells. These empty cells introduce a new data type called NULL LEFT JOIN SELECT a . id , a . name , o . total FROM accounts a LEFT JOIN orders o ON a . id = o . account_id RIGHT JOIN SELECT a . id , a . name , o . total FROM accounts a RIGHT JOIN orders o ON a . id = o . accounts_id Side Note: These are the same LEFT OUTER JOIN and LEFT JOIN RIGHT OUTER JOIN and RIGHT JOIN FULL OUTER JOIN and OUTER JOIN","title":"Types of JOINs"},{"location":"3_sql_aggregations/","text":"SQL Aggregations Introduction In this lesson, we will cover and you will be able to: Deal with NULL values Create aggregations in your SQL Queries including COUNT SUM MIN & MAX AVG GROUP BY DISTINCT HAVING Create DATE functions Implement CASE statements Summary of Aggregations Clause Description Null Treatment Alpha treatement COUNT Counts up all items in a column ignores NULL values Can be used SUM Adds up all numbers in a column ignores NULL values Cannot be used MIN returns the lowest number, earliest date, or non-numerical value as early in the alphabet as possible (a- Z) ignores NULL values Can be used MAX returns the highest number, earliest date, or non-numerical value as early in the alphabet as possible (Z- a) ignores NULL values Can be used AVG returns the mean of the data ignores NULL values Cannot be used NULL Datatype that specifiies that there is no data exists i.e. it does not necessarily mean 0 it is the absence of data. Protip We don't use =, because NULL isn't considered a value in SQL. Rather, it is a property of the data. Filtering for NULL SELECT * FROM table WHERE col_1 IS NULL Filtering for NOT NULL SELECT * FROM table WHERE col_1 IS NOT NULL Aggregations COUNT COUNT over all rows in a table SELECT COUNT ( * ) FROM accounts ; COUNT over speciic column (this will count only non NULL values) SELECT COUNT ( accounts . id ) FROM accounts ; SUM SELECT SUM ( standard_qty ) AS standard , SUM ( gloss_qty ) AS gloss , SUM ( poster_qty ) AS poster FROM orders MIN and MAX SELECT MIN ( standard_qty ) AS standard_min , MIN ( gloss_qty ) AS gloss_min , MIN ( poster_qty ) AS poster_min , MAX ( standard_qty ) AS standard_max , MAX ( gloss_qty ) AS gloss_max , MAX ( poster_qty ) AS poster_max FROM orders AVG SELECT AVG ( standard_qty ) AS standard_avg , AVG ( gloss_qty ) AS gloss_avg , AVG ( poster_qty ) AS poster_avg FROM orders AVG when you want to include NULLs as 0 Use the COALESCE function SELECT AVG ( COALESCE ( amount , 0 )) AS average_amount FROM table The innermost subquery retrieves the column_name values, assigns a unique row_num to each row using the ROW_NUMBER() function, and calculates the total number of rows in the table using the COUNT(*) OVER() function. /* output of subquery */ + -----------+--------+------------+ | column_name | row_num | total_rows | + -----------+--------+------------+ | 50 . 00 | 5 | 10 | | 60 . 00 | 6 | 10 | + -----------+--------+------------+ The middle subquery filters the rows that have a row_num equal to either FLOOR((total_rows + 1) / 2.0) or CEILING((total_rows + 1) / 2.0). If the number of rows in the table is odd, FLOOR((total_rows + 1) / 2.0) returns the exact middle row number, and the WHERE clause selects that row. If the number of rows in the table is even, FLOOR((total_rows + 1) / 2.0) and CEILING((total_rows + 1) / 2.0) return the two middle row numbers, and the WHERE clause selects those two rows. The outermost query calculates the median by taking the AVG() of the selected rows. In this case, since the sales table has an even number of rows, the middle subquery selects rows 5 and 6 with sales amounts of 50.00 and 60.00. Median (no function out the box) MEDIAN is more advanced to calculate SELECT column_name , row_num , total_rows FROM ( SELECT column_name , ROW_NUMBER () OVER ( ORDER BY column_name ) AS row_num , COUNT ( * ) OVER () AS total_rows FROM sales ) subquery WHERE row_num = FLOOR (( total_rows + 1 ) / 2 . 0 ) OR row_num = CEILING (( total_rows + 1 ) / 2 . 0 ); GROUP BY Used to aggregate subsets of data e.g. by region, age, gender Any column not in the SELECT statement that is not within an aggregator must be in the GROUP BY clause Goes between WHERE and ORDER BY SELECT col1 , col2 , SUM ( col2 ) total FROM table WHERE col2 = 'M' GROUP BY col1 ORDER BY total ORDER BY is temporary and will not change the table Evaluated before the LIMIT so all aggregations will be performed so there are no errors, but that means that if you are using LIMIT for performance reasons you won't get any benefit /* if you want a performance benefit use a subquery */ SELECT col1 , col2 , SUM ( col2 ) total FROM ( SELECT * FROM table LIMIT 100 ) as t1 WHERE col2 = 'M' GROUP BY col1 ORDER BY total You can GROUP BY multiple columns at once order of the columns in the ORDER BY does not matter you can subsitute numbers for columns DISTINCT Provides unique rows for all columns DISTINCT is always used in SELECT statements Only use DISTINCT once Correct SELECT DISTINCT column1 , column2 FROM table Wrong! SELECT DISTINCT column1 , DISTINCT column2 /* do not do this */ FROM table Case study Example data sale_id customer_name product_name sale_date 1 John T-shirt 2022-01-01 2 John T-shirt 2022-01-03 3 Sarah Hoodie 2022-01-02 4 Jane Jeans 2022-01-04 5 Jane Jeans 2022-01-05 6 John Jeans 2022-01-03 7 Sarah T-shirt 2022-01-04 8 Jane Hoodie 2022-01-05 Distinct on one column SELECT DISTINCT customer_name FROM sales ; Output customer_name John Sarah Jane Distinct on two columns SELECT DISTINCT customer_name , product_name FROM sales ; customer_name product_name John T-shirt Sarah Hoodie Jane Jeans John Jeans Sarah T-shirt Jane Hoodie Using Distinct with aggregations SELECT COUNT ( DISTINCT customer_name ), COUNT ( DISTINCT product_name ) FROM orders output COUNT(DISTINCT customer_name) COUNT(DISTINCT product_name) 3 3 HAVING Filtering a query that has aggregations Anytime you want to perform a WHERE on an aggregation you must use HAVING WHERE HAVING WHERE subsets the returned data based on logical condition works on logical statements involving aggregations appears after the FROM , JOIN and ON but before GROUP BY appears after the GROUP BY but before ORDER BY simple example SELECT account_id , SUM ( total_amt_usd ) AS sum_total_amt_usd FROM orders GROUP BY 1 HAVING SUM ( total_amt_usd ) >= 250000 example of WHERE and HAVING SELECT customer_id , COUNT ( * ) as num_orders , SUM ( order_total ) as total_sales FROM orders WHERE order_date BETWEEN '2022-01-01' AND '2022-12-31' -- Only orders in 2022 GROUP BY customer_id HAVING COUNT ( * ) > 5 AND SUM ( order_total ) > 1000 ORDER BY total_sales DATE FUNCTIONS Database format YYYY MM DD - dates sorted alphabetically are in chronological order DATE_TRUNC truncates the date to the required position syntax DATE_TRUNC ( '<date option e.g. day>' , column_name ) options day month year example to groupby the year SELECT DATE_FUNC ( 'year' , occurred_at ) ord_year , SUM ( total_amt_usd ) total_spent FROM orders GROUP BY 1 ORDER BY 2 DESC ; DATE_PART extracts only that part of the DATE e.g. the month syntax DATE_PART ( '<date option e.g. day>' , column_name ) options dow i.e. day of week day month year Example for month from any year SELECT DATE_PART ( 'month' , occurred_at ) ord_month , SUM ( total_amt_usd ) total_spent FROM orders WHERE occurred_at BETWEEN '2014-01-01' AND '2017-01-01' GROUP BY 1 ORDER BY 2 DESC ; CASE The CASE statement always goes in the SELECT clause. CASE must include the following components: WHEN, THEN, and END. ELSE is an optional component to catch cases that didn\u2019t meet any of the other previous CASE conditions. You can make any conditional statement using any conditional operator (like WHERE) between WHEN and THEN. This includes stringing together multiple conditional statements using AND and OR. You can include multiple WHEN statements, as well as an ELSE statement again, to deal with any unaddressed conditions. SELECT account_id , CASE WHEN standard_qty = 0 OR standard_qty IS NULL THEN 0 ELSE standard_amt_usd / standard_qty END AS unit_price FROM orders LIMIT 10 ; SELECT account_id , occurred_at , total , CASE WHEN total > 500 THEN 'Over 500' WHEN total > 300 THEN '301 - 500' WHEN total > 100 THEN '101 - 300' ELSE '100 or under' END AS total_group FROM orders","title":"SQL Aggregations"},{"location":"3_sql_aggregations/#sql-aggregations","text":"","title":"SQL Aggregations"},{"location":"3_sql_aggregations/#introduction","text":"In this lesson, we will cover and you will be able to: Deal with NULL values Create aggregations in your SQL Queries including COUNT SUM MIN & MAX AVG GROUP BY DISTINCT HAVING Create DATE functions Implement CASE statements","title":"Introduction"},{"location":"3_sql_aggregations/#summary-of-aggregations","text":"Clause Description Null Treatment Alpha treatement COUNT Counts up all items in a column ignores NULL values Can be used SUM Adds up all numbers in a column ignores NULL values Cannot be used MIN returns the lowest number, earliest date, or non-numerical value as early in the alphabet as possible (a- Z) ignores NULL values Can be used MAX returns the highest number, earliest date, or non-numerical value as early in the alphabet as possible (Z- a) ignores NULL values Can be used AVG returns the mean of the data ignores NULL values Cannot be used","title":"Summary of Aggregations"},{"location":"3_sql_aggregations/#null","text":"Datatype that specifiies that there is no data exists i.e. it does not necessarily mean 0 it is the absence of data. Protip We don't use =, because NULL isn't considered a value in SQL. Rather, it is a property of the data. Filtering for NULL SELECT * FROM table WHERE col_1 IS NULL Filtering for NOT NULL SELECT * FROM table WHERE col_1 IS NOT NULL","title":"NULL"},{"location":"3_sql_aggregations/#aggregations","text":"","title":"Aggregations"},{"location":"3_sql_aggregations/#count","text":"COUNT over all rows in a table SELECT COUNT ( * ) FROM accounts ; COUNT over speciic column (this will count only non NULL values) SELECT COUNT ( accounts . id ) FROM accounts ;","title":"COUNT"},{"location":"3_sql_aggregations/#sum","text":"SELECT SUM ( standard_qty ) AS standard , SUM ( gloss_qty ) AS gloss , SUM ( poster_qty ) AS poster FROM orders","title":"SUM"},{"location":"3_sql_aggregations/#min-and-max","text":"SELECT MIN ( standard_qty ) AS standard_min , MIN ( gloss_qty ) AS gloss_min , MIN ( poster_qty ) AS poster_min , MAX ( standard_qty ) AS standard_max , MAX ( gloss_qty ) AS gloss_max , MAX ( poster_qty ) AS poster_max FROM orders","title":"MIN and MAX"},{"location":"3_sql_aggregations/#avg","text":"SELECT AVG ( standard_qty ) AS standard_avg , AVG ( gloss_qty ) AS gloss_avg , AVG ( poster_qty ) AS poster_avg FROM orders AVG when you want to include NULLs as 0 Use the COALESCE function SELECT AVG ( COALESCE ( amount , 0 )) AS average_amount FROM table The innermost subquery retrieves the column_name values, assigns a unique row_num to each row using the ROW_NUMBER() function, and calculates the total number of rows in the table using the COUNT(*) OVER() function. /* output of subquery */ + -----------+--------+------------+ | column_name | row_num | total_rows | + -----------+--------+------------+ | 50 . 00 | 5 | 10 | | 60 . 00 | 6 | 10 | + -----------+--------+------------+ The middle subquery filters the rows that have a row_num equal to either FLOOR((total_rows + 1) / 2.0) or CEILING((total_rows + 1) / 2.0). If the number of rows in the table is odd, FLOOR((total_rows + 1) / 2.0) returns the exact middle row number, and the WHERE clause selects that row. If the number of rows in the table is even, FLOOR((total_rows + 1) / 2.0) and CEILING((total_rows + 1) / 2.0) return the two middle row numbers, and the WHERE clause selects those two rows. The outermost query calculates the median by taking the AVG() of the selected rows. In this case, since the sales table has an even number of rows, the middle subquery selects rows 5 and 6 with sales amounts of 50.00 and 60.00.","title":"AVG"},{"location":"3_sql_aggregations/#median-no-function-out-the-box","text":"MEDIAN is more advanced to calculate SELECT column_name , row_num , total_rows FROM ( SELECT column_name , ROW_NUMBER () OVER ( ORDER BY column_name ) AS row_num , COUNT ( * ) OVER () AS total_rows FROM sales ) subquery WHERE row_num = FLOOR (( total_rows + 1 ) / 2 . 0 ) OR row_num = CEILING (( total_rows + 1 ) / 2 . 0 );","title":"Median (no function out the box)"},{"location":"3_sql_aggregations/#group-by","text":"Used to aggregate subsets of data e.g. by region, age, gender Any column not in the SELECT statement that is not within an aggregator must be in the GROUP BY clause Goes between WHERE and ORDER BY SELECT col1 , col2 , SUM ( col2 ) total FROM table WHERE col2 = 'M' GROUP BY col1 ORDER BY total ORDER BY is temporary and will not change the table Evaluated before the LIMIT so all aggregations will be performed so there are no errors, but that means that if you are using LIMIT for performance reasons you won't get any benefit /* if you want a performance benefit use a subquery */ SELECT col1 , col2 , SUM ( col2 ) total FROM ( SELECT * FROM table LIMIT 100 ) as t1 WHERE col2 = 'M' GROUP BY col1 ORDER BY total You can GROUP BY multiple columns at once order of the columns in the ORDER BY does not matter you can subsitute numbers for columns","title":"GROUP BY"},{"location":"3_sql_aggregations/#distinct","text":"Provides unique rows for all columns DISTINCT is always used in SELECT statements Only use DISTINCT once Correct SELECT DISTINCT column1 , column2 FROM table Wrong! SELECT DISTINCT column1 , DISTINCT column2 /* do not do this */ FROM table Case study Example data sale_id customer_name product_name sale_date 1 John T-shirt 2022-01-01 2 John T-shirt 2022-01-03 3 Sarah Hoodie 2022-01-02 4 Jane Jeans 2022-01-04 5 Jane Jeans 2022-01-05 6 John Jeans 2022-01-03 7 Sarah T-shirt 2022-01-04 8 Jane Hoodie 2022-01-05 Distinct on one column SELECT DISTINCT customer_name FROM sales ; Output customer_name John Sarah Jane Distinct on two columns SELECT DISTINCT customer_name , product_name FROM sales ; customer_name product_name John T-shirt Sarah Hoodie Jane Jeans John Jeans Sarah T-shirt Jane Hoodie Using Distinct with aggregations SELECT COUNT ( DISTINCT customer_name ), COUNT ( DISTINCT product_name ) FROM orders output COUNT(DISTINCT customer_name) COUNT(DISTINCT product_name) 3 3","title":"DISTINCT"},{"location":"3_sql_aggregations/#having","text":"Filtering a query that has aggregations Anytime you want to perform a WHERE on an aggregation you must use HAVING WHERE HAVING WHERE subsets the returned data based on logical condition works on logical statements involving aggregations appears after the FROM , JOIN and ON but before GROUP BY appears after the GROUP BY but before ORDER BY simple example SELECT account_id , SUM ( total_amt_usd ) AS sum_total_amt_usd FROM orders GROUP BY 1 HAVING SUM ( total_amt_usd ) >= 250000 example of WHERE and HAVING SELECT customer_id , COUNT ( * ) as num_orders , SUM ( order_total ) as total_sales FROM orders WHERE order_date BETWEEN '2022-01-01' AND '2022-12-31' -- Only orders in 2022 GROUP BY customer_id HAVING COUNT ( * ) > 5 AND SUM ( order_total ) > 1000 ORDER BY total_sales","title":"HAVING"},{"location":"3_sql_aggregations/#date-functions","text":"Database format YYYY MM DD - dates sorted alphabetically are in chronological order","title":"DATE FUNCTIONS"},{"location":"3_sql_aggregations/#date_trunc","text":"truncates the date to the required position syntax DATE_TRUNC ( '<date option e.g. day>' , column_name ) options day month year example to groupby the year SELECT DATE_FUNC ( 'year' , occurred_at ) ord_year , SUM ( total_amt_usd ) total_spent FROM orders GROUP BY 1 ORDER BY 2 DESC ;","title":"DATE_TRUNC"},{"location":"3_sql_aggregations/#date_part","text":"extracts only that part of the DATE e.g. the month syntax DATE_PART ( '<date option e.g. day>' , column_name ) options dow i.e. day of week day month year Example for month from any year SELECT DATE_PART ( 'month' , occurred_at ) ord_month , SUM ( total_amt_usd ) total_spent FROM orders WHERE occurred_at BETWEEN '2014-01-01' AND '2017-01-01' GROUP BY 1 ORDER BY 2 DESC ;","title":"DATE_PART"},{"location":"3_sql_aggregations/#case","text":"The CASE statement always goes in the SELECT clause. CASE must include the following components: WHEN, THEN, and END. ELSE is an optional component to catch cases that didn\u2019t meet any of the other previous CASE conditions. You can make any conditional statement using any conditional operator (like WHERE) between WHEN and THEN. This includes stringing together multiple conditional statements using AND and OR. You can include multiple WHEN statements, as well as an ELSE statement again, to deal with any unaddressed conditions. SELECT account_id , CASE WHEN standard_qty = 0 OR standard_qty IS NULL THEN 0 ELSE standard_amt_usd / standard_qty END AS unit_price FROM orders LIMIT 10 ; SELECT account_id , occurred_at , total , CASE WHEN total > 500 THEN 'Over 500' WHEN total > 300 THEN '301 - 500' WHEN total > 100 THEN '101 - 300' ELSE '100 or under' END AS total_group FROM orders","title":"CASE"},{"location":"4_sql_sub_queries_temp_tables/","text":"Sub queries and Temp tables Subquery: a query that runs within an outer query SELECT product_id , name , price FROM db . product Where price > ( SELECT AVG ( price ) FROM db . product ) -- right part is subquery When do you need a subquery? manipulating an existing table to \"pseudo-create\" a table which is used as part of a larger query Example of when to use subqueries Identify the top-selling Amazon products in months where sales have exceeded $1m Existing Table: Amazon daily sales Subquery Aggregation: Daily to Monthly Examine the average price of a brand\u2019s products for the highest-grossing brands Existing Table: Product pricing data across all retailers Subquery Aggregation: Individual to Average Order the annual salary of employees that are working less than 150 hours a month Existing Table: Daily time-table of employees Subquery Aggregation: Daily to Monthly Subqueries VS JOINs Factor Subquery Join Use cases When an existing table needs to be manipulated or aggregated to then be joined to a larger table. A fully flexible and discretionary use case where a user wants to bring two or more tables together and select and filter as needed. Syntax A subquery is a query within a query. The syntax, as a result, has multiple SELECT and FROM clauses. A join is simple stitching together multiple tables with a common key or column. A join clause cannot stand and be run independently Dependencies A subquery clause can be run completely independently. When trying to debug code, subqueries are often run independently to pressure test results before running the larger query. A join clause cannot stand and be run independently. Output Both subqueries and joins are essentially bringing multiple tables together (whether an existing table is first manipulated or not) to generate a single output. Same as previous cell to the left Deep Dive Topics What happens under the hood: Query plans are similar for both subqueries and joins, read this link Same as previous cell to the left Subquery Basics Must be fully placed inside paranthesis Must be fully independent and can be executed on their own (except Correlated subqueries) Two components of subqueries Placement - Where it is placed With also known as a common table expression (CTE) allows you to define a temporary named result set that can be referenced multiple times within a larger query common use case is to simplify complex queries or create a temp table with limited rows to improve performance WITH top_paid_employees AS ( SELECT employee_id , first_name , last_name , salary FROM employees ORDER BY salary DESC LIMIT 10 ) SELECT e . employee_id , e . first_name , e . last_name , e . department_id , tpe . salary FROM employees e JOIN top_paid_employees tpe ON e . employee_id = tpe . employee_id ; Inline like a with but not ontop This subquery is used in the same fashion as the WITH use case above. However, instead of the temporary table sitting on top of the larger query, it\u2019s embedded within the from clause. SELECT student_name FROM ( SELECT student_id , student_name , grade FROM student WHERE teacher = 10 ) WHERE grade > 80 ; Nested A nested subquery is a subquery that is embedded within another subquery or the main query SELECT department_name FROM departments d WHERE department_id IN ( SELECT department_id FROM employees GROUP BY department_id HAVING COUNT ( * ) > 5 ); Scalar A scalar subquery is a subquery that returns a single value, which can be used as part of an expression in the main query SELECT employee_id , first_name , last_name , salary , ( SELECT MIN ( salary ) FROM employees ) AS min_salary FROM employees ; Dependencies - with the outer/larger query Simple - The inner subquery is completely independent of the larger query. example 1 WITH dept_average AS ( SELECT dept , AVG ( salary ) AS avg_dept_salary FROM employee GROUP BY employee . dept ) SELECT E . eid , E . ename , D . avg_dept_salary FROM employee E JOIN dept . average D ON E . dept = D . dept WHERE E . salary > D . avg_dept_salary Correlated - The inner subquery is dependent on the larger query. example 1 SELECT employee_id , name FROM employees_db emp WHERE salary > ( SELECT AVG ( salary ) FROM employees_db WHERE department = emp . department ); example 2 (pretty sure you can do this with a groupby) SELECT first_name , last_name , ( SELECT AVG ( GPA ) FROM outer_db WHERE university = outer_db . university ) GPA , university FROM student_db outer_db ; example 3 SELECT first_name , last_name , GPA , university FROM student_db outer_db WHERE GPA > ( SELECT AVG ( GPA ) FROM student_db WHERE university = outer_db . university ); Advantages Nested and With are good for readability Scalar are good for performance picture that shows how correlated queries are linked from outer to inner query SQL Views Views are virtual tables that are derived from one or more base tables. The term virtual means that the views do not exist physically in a database, instead, they reside in the memory (not database), just like the result of any query is stored in the memory. Syntax for creating a view CREATE VIEW < VIEW_NAME > AS SELECT \u2026 FROM \u2026 WHERE \u2026 CREATE VIEW v1 AS SELECT S . id , S . name AS Rep_Name , R . name AS Region_Name FROM sales_reps S JOIN region R ON S . region_id = R . id AND R . name = 'Northeast' ; Can we update the base tables by updating a view? Since views do not exist physically in the database, it is may or may not be possible to execute UPDATE operations on views. It depends on the SELECT query used in the view definition. Generally, if the SELECT statement contains either an AGGREGATE function, GROUPING, or JOIN, then the view may not update the underlying base tables. Can we insert or delete a tuple in the base table by inserting or deleting a tuple in a view? Again, it depends on the view definition. If a view is created from a single base table, then yes, you can insert/delete tuples by doing so in the view. Can we alter the view definition? Most of the databases allow you to alter a view. For example, Oracle and IBM DB2 allows us to alter views and provides CREATE OR REPLACE VIEW option to redefine a view. CREATE OR ALTER VIEW my_view AS SELECT column1 , column2 , column3 , column4 FROM my_table WHERE column5 = 'new value' ; Subquery tradeoffs Readability : How easy it is to determine what the code is doing Performance : How quickly the code runs Query Plan : What happens under the hood link for a good guide to sql optimization Subquery strategy Determine if a subquery is needed (or a join/aggregation function will suffice). If a subquery is needed, determine where you\u2019ll need to place it. Run the subquery as an independent query first: is the output what you expect? Call it something! If you are working with With or Inline subquery, you\u2019ll most certainly need to name it. Run the entire query -- both the inner query and outer query.","title":"SQL Sub Queries & Temp Tables"},{"location":"4_sql_sub_queries_temp_tables/#sub-queries-and-temp-tables","text":"Subquery: a query that runs within an outer query SELECT product_id , name , price FROM db . product Where price > ( SELECT AVG ( price ) FROM db . product ) -- right part is subquery","title":"Sub queries and Temp tables"},{"location":"4_sql_sub_queries_temp_tables/#when-do-you-need-a-subquery","text":"manipulating an existing table to \"pseudo-create\" a table which is used as part of a larger query Example of when to use subqueries Identify the top-selling Amazon products in months where sales have exceeded $1m Existing Table: Amazon daily sales Subquery Aggregation: Daily to Monthly Examine the average price of a brand\u2019s products for the highest-grossing brands Existing Table: Product pricing data across all retailers Subquery Aggregation: Individual to Average Order the annual salary of employees that are working less than 150 hours a month Existing Table: Daily time-table of employees Subquery Aggregation: Daily to Monthly","title":"When do you need a subquery?"},{"location":"4_sql_sub_queries_temp_tables/#subqueries-vs-joins","text":"Factor Subquery Join Use cases When an existing table needs to be manipulated or aggregated to then be joined to a larger table. A fully flexible and discretionary use case where a user wants to bring two or more tables together and select and filter as needed. Syntax A subquery is a query within a query. The syntax, as a result, has multiple SELECT and FROM clauses. A join is simple stitching together multiple tables with a common key or column. A join clause cannot stand and be run independently Dependencies A subquery clause can be run completely independently. When trying to debug code, subqueries are often run independently to pressure test results before running the larger query. A join clause cannot stand and be run independently. Output Both subqueries and joins are essentially bringing multiple tables together (whether an existing table is first manipulated or not) to generate a single output. Same as previous cell to the left Deep Dive Topics What happens under the hood: Query plans are similar for both subqueries and joins, read this link Same as previous cell to the left","title":"Subqueries VS JOINs"},{"location":"4_sql_sub_queries_temp_tables/#subquery-basics","text":"Must be fully placed inside paranthesis Must be fully independent and can be executed on their own (except Correlated subqueries) Two components of subqueries Placement - Where it is placed With also known as a common table expression (CTE) allows you to define a temporary named result set that can be referenced multiple times within a larger query common use case is to simplify complex queries or create a temp table with limited rows to improve performance WITH top_paid_employees AS ( SELECT employee_id , first_name , last_name , salary FROM employees ORDER BY salary DESC LIMIT 10 ) SELECT e . employee_id , e . first_name , e . last_name , e . department_id , tpe . salary FROM employees e JOIN top_paid_employees tpe ON e . employee_id = tpe . employee_id ; Inline like a with but not ontop This subquery is used in the same fashion as the WITH use case above. However, instead of the temporary table sitting on top of the larger query, it\u2019s embedded within the from clause. SELECT student_name FROM ( SELECT student_id , student_name , grade FROM student WHERE teacher = 10 ) WHERE grade > 80 ; Nested A nested subquery is a subquery that is embedded within another subquery or the main query SELECT department_name FROM departments d WHERE department_id IN ( SELECT department_id FROM employees GROUP BY department_id HAVING COUNT ( * ) > 5 ); Scalar A scalar subquery is a subquery that returns a single value, which can be used as part of an expression in the main query SELECT employee_id , first_name , last_name , salary , ( SELECT MIN ( salary ) FROM employees ) AS min_salary FROM employees ; Dependencies - with the outer/larger query Simple - The inner subquery is completely independent of the larger query. example 1 WITH dept_average AS ( SELECT dept , AVG ( salary ) AS avg_dept_salary FROM employee GROUP BY employee . dept ) SELECT E . eid , E . ename , D . avg_dept_salary FROM employee E JOIN dept . average D ON E . dept = D . dept WHERE E . salary > D . avg_dept_salary Correlated - The inner subquery is dependent on the larger query. example 1 SELECT employee_id , name FROM employees_db emp WHERE salary > ( SELECT AVG ( salary ) FROM employees_db WHERE department = emp . department ); example 2 (pretty sure you can do this with a groupby) SELECT first_name , last_name , ( SELECT AVG ( GPA ) FROM outer_db WHERE university = outer_db . university ) GPA , university FROM student_db outer_db ; example 3 SELECT first_name , last_name , GPA , university FROM student_db outer_db WHERE GPA > ( SELECT AVG ( GPA ) FROM student_db WHERE university = outer_db . university ); Advantages Nested and With are good for readability Scalar are good for performance picture that shows how correlated queries are linked from outer to inner query","title":"Subquery Basics"},{"location":"4_sql_sub_queries_temp_tables/#sql-views","text":"Views are virtual tables that are derived from one or more base tables. The term virtual means that the views do not exist physically in a database, instead, they reside in the memory (not database), just like the result of any query is stored in the memory. Syntax for creating a view CREATE VIEW < VIEW_NAME > AS SELECT \u2026 FROM \u2026 WHERE \u2026 CREATE VIEW v1 AS SELECT S . id , S . name AS Rep_Name , R . name AS Region_Name FROM sales_reps S JOIN region R ON S . region_id = R . id AND R . name = 'Northeast' ; Can we update the base tables by updating a view? Since views do not exist physically in the database, it is may or may not be possible to execute UPDATE operations on views. It depends on the SELECT query used in the view definition. Generally, if the SELECT statement contains either an AGGREGATE function, GROUPING, or JOIN, then the view may not update the underlying base tables. Can we insert or delete a tuple in the base table by inserting or deleting a tuple in a view? Again, it depends on the view definition. If a view is created from a single base table, then yes, you can insert/delete tuples by doing so in the view. Can we alter the view definition? Most of the databases allow you to alter a view. For example, Oracle and IBM DB2 allows us to alter views and provides CREATE OR REPLACE VIEW option to redefine a view. CREATE OR ALTER VIEW my_view AS SELECT column1 , column2 , column3 , column4 FROM my_table WHERE column5 = 'new value' ;","title":"SQL Views"},{"location":"4_sql_sub_queries_temp_tables/#subquery-tradeoffs","text":"Readability : How easy it is to determine what the code is doing Performance : How quickly the code runs Query Plan : What happens under the hood link for a good guide to sql optimization","title":"Subquery tradeoffs"},{"location":"4_sql_sub_queries_temp_tables/#subquery-strategy","text":"Determine if a subquery is needed (or a join/aggregation function will suffice). If a subquery is needed, determine where you\u2019ll need to place it. Run the subquery as an independent query first: is the output what you expect? Call it something! If you are working with With or Inline subquery, you\u2019ll most certainly need to name it. Run the entire query -- both the inner query and outer query.","title":"Subquery strategy"},{"location":"5_sql_data_cleaning/","text":"SQL data cleaning Introduction Clean and re-structure messy data. Convert columns to different data types. Tricks for manipulating NULLs. Functions covered LEFT - extracts the number of characters from a string starting from the left RIGHT - extracts the number of characters from a string starting from the right SUBSTR - extracts the substring from a string (starting at any position) POSITION - returns the position of the first occurence of a substring in a string STRPOS - Returns the position of substring within a string CONCAT - adds two or more expressions together CAST - covers a value of any type into a specific, different data type COALESCE - returns the first non-null value in a list Data Cleaning Strategy What data do you need?: Review what data you need to run an analysis and solve the problem at hand. What data do you have?: Take stock of not only the information you have in your dataset today but what data types those fields are. Do these align with your data needs? How will you clean your data?: Build a game plan of how you\u2019ll convert the data you currently have to the data you need. What types of actions and data cleaning techniques will you have to apply? Do you have the skills you need to go from the current to future state? How will you analyze your data?: Now, it\u2019s game time! How do you run an effective analysis? Build an approach for analysis, as well. And visualize your plan to solve the problem. Finally, remember to question \u201cso what?\u201d at the end of your results, which will help drive recommendations for your organization. SELECT LEFT ( primary_poc , STRPOS ( primary_poc , ' ' ) - 1 ) first_name , RIGHT ( primary_poc , LENGTH ( primary_poc ) - STRPOS ( primary_poc , ' ' )) last_name FROM accounts ; Commonly used function LEFT LEFT ( string , number_of_character ) AS column_name Note number_of_characters is inclusive i.e. LEFT('ABC', 2) => 'AB' RIGHT RIGHT ( string , number_of_character ) AS column_name Note number_of_characters is inclusive i.e. RIGHT('ABC', 2) => 'BC' SUBSTR SUBSTR ( string , start , length ) string: the string you are parsing start: the start position of the extraction length: number of characters to extract SUBSTR ( col , 11 , 1 ) AS gender STRING_SPLIT WITH table AS ( SELECT student_information , value , ROW _NUMBER () OVER ( PARTITION BY student_information ORDER BY ( SELECT NULL )) AS row_number FROM student_db CROSS APPLY STRING_SPLIT ( student_information , ',' ) AS back_values ) SELECT student_information , [ 1 ] AS STUDENT_ID , [ 2 ] AS GENDER , [ 3 ] AS CITY , [ 4 ] AS GPA , [ 5 ] AS SALARY FROM table PIVOT ( MAX ( VALUE ) FOR row_number IN ([ 1 ],[ 2 ],[ 3 ],[ 4 ],[ 5 ]) ) AS PVT ) CONCAT CONCAT ( string1 , string2 , string3 ) CONCAT ( month , '-' , day , '-' , year ) AS date CAST CAST ( expression as datatype ) CAST ( salary AS int ) SELECT date orig_date , ( SUBSTR ( date , 7 , 4 ) || '-' || LEFT ( date , 2 ) || '-' || SUBSTR ( date , 4 , 2 )):: DATE new_date -- some other way you can cast FROM sf_crime_data ; POSITION POSITION ( substring IN string ) POSITION ( \"$\" IN student_information ) as salary_starting_position STRPOS STRPOS ( string , substring ) SELECT LEFT ( name , STRPOS ( name , ' ' ) - 1 ) first_name , RIGHT ( name , LENGTH ( name ) - STRPOS ( name , ' ' )) last_name FROM sales_reps ; COALESCE COALESCE ( val1 , val2 , val3 ) COALESCE ( hourly_wage * 40 * 52 , salary , commission * sales ) AS annual_income","title":"SQL Data Cleaning"},{"location":"5_sql_data_cleaning/#sql-data-cleaning","text":"","title":"SQL data cleaning"},{"location":"5_sql_data_cleaning/#introduction","text":"Clean and re-structure messy data. Convert columns to different data types. Tricks for manipulating NULLs. Functions covered LEFT - extracts the number of characters from a string starting from the left RIGHT - extracts the number of characters from a string starting from the right SUBSTR - extracts the substring from a string (starting at any position) POSITION - returns the position of the first occurence of a substring in a string STRPOS - Returns the position of substring within a string CONCAT - adds two or more expressions together CAST - covers a value of any type into a specific, different data type COALESCE - returns the first non-null value in a list","title":"Introduction"},{"location":"5_sql_data_cleaning/#data-cleaning-strategy","text":"What data do you need?: Review what data you need to run an analysis and solve the problem at hand. What data do you have?: Take stock of not only the information you have in your dataset today but what data types those fields are. Do these align with your data needs? How will you clean your data?: Build a game plan of how you\u2019ll convert the data you currently have to the data you need. What types of actions and data cleaning techniques will you have to apply? Do you have the skills you need to go from the current to future state? How will you analyze your data?: Now, it\u2019s game time! How do you run an effective analysis? Build an approach for analysis, as well. And visualize your plan to solve the problem. Finally, remember to question \u201cso what?\u201d at the end of your results, which will help drive recommendations for your organization. SELECT LEFT ( primary_poc , STRPOS ( primary_poc , ' ' ) - 1 ) first_name , RIGHT ( primary_poc , LENGTH ( primary_poc ) - STRPOS ( primary_poc , ' ' )) last_name FROM accounts ;","title":"Data Cleaning Strategy"},{"location":"5_sql_data_cleaning/#commonly-used-function","text":"","title":"Commonly used function"},{"location":"5_sql_data_cleaning/#left","text":"LEFT ( string , number_of_character ) AS column_name Note number_of_characters is inclusive i.e. LEFT('ABC', 2) => 'AB'","title":"LEFT"},{"location":"5_sql_data_cleaning/#right","text":"RIGHT ( string , number_of_character ) AS column_name Note number_of_characters is inclusive i.e. RIGHT('ABC', 2) => 'BC'","title":"RIGHT"},{"location":"5_sql_data_cleaning/#substr","text":"SUBSTR ( string , start , length ) string: the string you are parsing start: the start position of the extraction length: number of characters to extract SUBSTR ( col , 11 , 1 ) AS gender","title":"SUBSTR"},{"location":"5_sql_data_cleaning/#string_split","text":"WITH table AS ( SELECT student_information , value , ROW _NUMBER () OVER ( PARTITION BY student_information ORDER BY ( SELECT NULL )) AS row_number FROM student_db CROSS APPLY STRING_SPLIT ( student_information , ',' ) AS back_values ) SELECT student_information , [ 1 ] AS STUDENT_ID , [ 2 ] AS GENDER , [ 3 ] AS CITY , [ 4 ] AS GPA , [ 5 ] AS SALARY FROM table PIVOT ( MAX ( VALUE ) FOR row_number IN ([ 1 ],[ 2 ],[ 3 ],[ 4 ],[ 5 ]) ) AS PVT )","title":"STRING_SPLIT"},{"location":"5_sql_data_cleaning/#concat","text":"CONCAT ( string1 , string2 , string3 ) CONCAT ( month , '-' , day , '-' , year ) AS date","title":"CONCAT"},{"location":"5_sql_data_cleaning/#cast","text":"CAST ( expression as datatype ) CAST ( salary AS int ) SELECT date orig_date , ( SUBSTR ( date , 7 , 4 ) || '-' || LEFT ( date , 2 ) || '-' || SUBSTR ( date , 4 , 2 )):: DATE new_date -- some other way you can cast FROM sf_crime_data ;","title":"CAST"},{"location":"5_sql_data_cleaning/#position","text":"POSITION ( substring IN string ) POSITION ( \"$\" IN student_information ) as salary_starting_position","title":"POSITION"},{"location":"5_sql_data_cleaning/#strpos","text":"STRPOS ( string , substring ) SELECT LEFT ( name , STRPOS ( name , ' ' ) - 1 ) first_name , RIGHT ( name , LENGTH ( name ) - STRPOS ( name , ' ' )) last_name FROM sales_reps ;","title":"STRPOS"},{"location":"5_sql_data_cleaning/#coalesce","text":"COALESCE ( val1 , val2 , val3 ) COALESCE ( hourly_wage * 40 * 52 , salary , commission * sales ) AS annual_income","title":"COALESCE"},{"location":"6_sql_windows_functions/","text":"SQL Window Functions Introdution In this lesson, we will cover window functions. Window functions are primarily used in two ways: To understand a running total or a running metric while maintaining individual records To rank a dataset At the end of this lesson, you will be able to create windows functions using: Core Functions Ranking Functions Advanced Functions When to use window functions When you want to measure trends or changes over rows or records in your data When you want to rank a column for outreach or prioritization Measuring changes over time Has the average price of airline tickets gone up this year Whats the best way to keep the running total orders of customers The ranking used for outreach prioritization: Use a combinationof factors to rank companies most likely to need a loan Terms Partition by: A subclause of the OVER clause. Similar to GROUP BY. Over: Typically precedes the partition by that signals what to \u201cGROUP BY\u201d. Aggregates: Aggregate functions that are used in window functions, too (e.g., sum, count, avg). Row_number(): Ranking function where each row gets a different number. Rank(): Ranking function where a row could get the same rank if they have the same value. Dense_rank(): Ranking function similar to rank() but ranks are not skipped with ties. Aliases: Shorthand that can be used if there are several window functions in one query. Percentiles: Defines what percentile a value falls into over the entire table. Lag/Lead: Calculating differences between rows\u2019 values. Syntax AGGREGATE_FUNCTION ( column_1 ) OVER ( PARTITION BY column_2 ORDER BY column_3 ) AS new_column_name 1. An aggregation function (e.g., sum, count, or average) + the column you\u2019d like to track 2. OVER 3. PARTITION BY + the column you\u2019d like to \u201cgroup by\u201d 4. ORDER BY (optional and is often a date column) 5. AS + the new column name useful link GROUP BY vs PARTITION BY GROUP BY PARTITION BY The output has a lessened # of records based on the group by column The output maintains the # of records in the original table The output is one row per group by in the results set If the original table had 10 rows, the partition by will maintain 10 rows Note : You can't use a window function and standard aggregations in the same query. you can\u2019t include window functions in a GROUP BY clause. SELECT order_id , order_total , order_price , SUM ( order_total ) OVER ( PARTITION BY month ( order_date ) ORDER BY order_date ) AS running_monthly_sales , COUNT ( order_id ) OVER ( PARTITION BY month ( order_date ) ORDER BY order_date ) AS running_monthly orders , AVG ( order_price ) OVER ( PARTITION BY month ( order_date ) ORDER BY order_date ) AS average_monthly_price FROM amazon_sales_db WHERE order_date < '2017-01-01' ; Ranking Window Functions ROW_NUMBER() : Ranking is distinct amongst records even with ties in what the table is ranked against RANK() : The same amongst tied values and rank skip for subsquent values DENSE_RANK() : Ranking is the same amongst tied values and ranks do not skip for subsquent values name score row_num rank dense_rank Charlie 90 1 1 1 Emily 90 2 1 1 Bob 85 3 3 2 Dave 85 4 3 2 Alice 80 5 5 3 Frank 75 6 6 4 SELECT name , score , ROW_NUMBER () OVER ( ORDER BY score DESC ) as row_num , RANK () OVER ( ORDER BY score DESC ) as rank , DENSE_RANK () OVER ( ORDER BY score DESC ) as dense_rank FROM students ; Alias for window functions A monthly_window alias function is defined at the end of the query in the WINDOW clause. It is then called on each time an aggregate function is used within the SELECT clause. syntax /* previous sql code */ SELECT AGGREGATE_FUNCTION ( column ) OVER monthly_windows AS column_name WHERE ... WINDOW monthly_window AS ( PARTITION BY month ( order_date ) ORDER BY order_date ); SELECT order_id , order_total , order_price , SUM ( order_total ) OVER monthly_window AS running_monthly_sales , COUNT ( order_id ) OVER monthly_window AS running_monthly orders , AVG ( order_price ) OVER monthly_window AS average_monthly_price FROM amazon_sales_db WHERE order_date < '2017-01-01' WINDOW monthly_window AS ( PARTITION BY month ( order_date ) ORDER BY order_date ); LAG syntax SELECT LAG ( column_name ) OVER ( ORDER BY column_name ) AS lag SELECT account_id , standard_sum , LAG ( standard_sum ) OVER ( ORDER BY standard_sum ) AS lag standard_sum - LAG ( standard_sum ) OVER ( ORDER BY standard_sum ) AS lag_difference FROM ( SELECT account_id , SUM ( standard_qty ) AS standard_sum FROM orders GROUP BY 1 ) sub LEAD syntax SELECT LEAD ( column_name ) OVER ( ORDER BY column_name ) AS lead SELECT account_id , standard_sum , LEAD ( standard_sum ) OVER ( ORDER BY standard_sum ) AS lead standard_sum - LEAD ( standard_sum ) OVER ( ORDER BY standard_sum ) AS lead_difference FROM ( SELECT account_id , SUM ( standard_qty ) AS standard_sum FROM orders GROUP BY 1 ) sub Percentiles NTILE Syntax SELECT NTILE ( # of buckets ) OVER ( ORDER BY ranking_columns ) AS new_column_name Example -- NTILE(# of buckets) OVER (ORDER BY ranking_column) AS new_column_name SELECT customer_id , composite_score , NTILE ( 100 ) OVER ( ORDER BY composite_score ) AS percentile FROM customer_lead_score ; Example - get each quartile for each account_id SELECT account_id , occurred_at , standard_qty , NTILE ( 4 ) OVER ( PARTITION BY account_id ORDER BY standard_qty ) AS standard_quartile FROM orders ORDER BY account_id DESC","title":"SQL Window Functions"},{"location":"6_sql_windows_functions/#sql-window-functions","text":"","title":"SQL Window Functions"},{"location":"6_sql_windows_functions/#introdution","text":"In this lesson, we will cover window functions. Window functions are primarily used in two ways: To understand a running total or a running metric while maintaining individual records To rank a dataset At the end of this lesson, you will be able to create windows functions using: Core Functions Ranking Functions Advanced Functions","title":"Introdution"},{"location":"6_sql_windows_functions/#when-to-use-window-functions","text":"When you want to measure trends or changes over rows or records in your data When you want to rank a column for outreach or prioritization Measuring changes over time Has the average price of airline tickets gone up this year Whats the best way to keep the running total orders of customers The ranking used for outreach prioritization: Use a combinationof factors to rank companies most likely to need a loan","title":"When to use window functions"},{"location":"6_sql_windows_functions/#terms","text":"Partition by: A subclause of the OVER clause. Similar to GROUP BY. Over: Typically precedes the partition by that signals what to \u201cGROUP BY\u201d. Aggregates: Aggregate functions that are used in window functions, too (e.g., sum, count, avg). Row_number(): Ranking function where each row gets a different number. Rank(): Ranking function where a row could get the same rank if they have the same value. Dense_rank(): Ranking function similar to rank() but ranks are not skipped with ties. Aliases: Shorthand that can be used if there are several window functions in one query. Percentiles: Defines what percentile a value falls into over the entire table. Lag/Lead: Calculating differences between rows\u2019 values.","title":"Terms"},{"location":"6_sql_windows_functions/#syntax","text":"AGGREGATE_FUNCTION ( column_1 ) OVER ( PARTITION BY column_2 ORDER BY column_3 ) AS new_column_name 1. An aggregation function (e.g., sum, count, or average) + the column you\u2019d like to track 2. OVER 3. PARTITION BY + the column you\u2019d like to \u201cgroup by\u201d 4. ORDER BY (optional and is often a date column) 5. AS + the new column name useful link","title":"Syntax"},{"location":"6_sql_windows_functions/#group-by-vs-partition-by","text":"GROUP BY PARTITION BY The output has a lessened # of records based on the group by column The output maintains the # of records in the original table The output is one row per group by in the results set If the original table had 10 rows, the partition by will maintain 10 rows Note : You can't use a window function and standard aggregations in the same query. you can\u2019t include window functions in a GROUP BY clause. SELECT order_id , order_total , order_price , SUM ( order_total ) OVER ( PARTITION BY month ( order_date ) ORDER BY order_date ) AS running_monthly_sales , COUNT ( order_id ) OVER ( PARTITION BY month ( order_date ) ORDER BY order_date ) AS running_monthly orders , AVG ( order_price ) OVER ( PARTITION BY month ( order_date ) ORDER BY order_date ) AS average_monthly_price FROM amazon_sales_db WHERE order_date < '2017-01-01' ;","title":"GROUP BY vs PARTITION BY"},{"location":"6_sql_windows_functions/#ranking-window-functions","text":"ROW_NUMBER() : Ranking is distinct amongst records even with ties in what the table is ranked against RANK() : The same amongst tied values and rank skip for subsquent values DENSE_RANK() : Ranking is the same amongst tied values and ranks do not skip for subsquent values name score row_num rank dense_rank Charlie 90 1 1 1 Emily 90 2 1 1 Bob 85 3 3 2 Dave 85 4 3 2 Alice 80 5 5 3 Frank 75 6 6 4 SELECT name , score , ROW_NUMBER () OVER ( ORDER BY score DESC ) as row_num , RANK () OVER ( ORDER BY score DESC ) as rank , DENSE_RANK () OVER ( ORDER BY score DESC ) as dense_rank FROM students ;","title":"Ranking Window Functions"},{"location":"6_sql_windows_functions/#alias-for-window-functions","text":"A monthly_window alias function is defined at the end of the query in the WINDOW clause. It is then called on each time an aggregate function is used within the SELECT clause. syntax /* previous sql code */ SELECT AGGREGATE_FUNCTION ( column ) OVER monthly_windows AS column_name WHERE ... WINDOW monthly_window AS ( PARTITION BY month ( order_date ) ORDER BY order_date ); SELECT order_id , order_total , order_price , SUM ( order_total ) OVER monthly_window AS running_monthly_sales , COUNT ( order_id ) OVER monthly_window AS running_monthly orders , AVG ( order_price ) OVER monthly_window AS average_monthly_price FROM amazon_sales_db WHERE order_date < '2017-01-01' WINDOW monthly_window AS ( PARTITION BY month ( order_date ) ORDER BY order_date );","title":"Alias for window functions"},{"location":"6_sql_windows_functions/#lag","text":"syntax SELECT LAG ( column_name ) OVER ( ORDER BY column_name ) AS lag SELECT account_id , standard_sum , LAG ( standard_sum ) OVER ( ORDER BY standard_sum ) AS lag standard_sum - LAG ( standard_sum ) OVER ( ORDER BY standard_sum ) AS lag_difference FROM ( SELECT account_id , SUM ( standard_qty ) AS standard_sum FROM orders GROUP BY 1 ) sub","title":"LAG"},{"location":"6_sql_windows_functions/#lead","text":"syntax SELECT LEAD ( column_name ) OVER ( ORDER BY column_name ) AS lead SELECT account_id , standard_sum , LEAD ( standard_sum ) OVER ( ORDER BY standard_sum ) AS lead standard_sum - LEAD ( standard_sum ) OVER ( ORDER BY standard_sum ) AS lead_difference FROM ( SELECT account_id , SUM ( standard_qty ) AS standard_sum FROM orders GROUP BY 1 ) sub","title":"LEAD"},{"location":"6_sql_windows_functions/#percentiles-ntile","text":"Syntax SELECT NTILE ( # of buckets ) OVER ( ORDER BY ranking_columns ) AS new_column_name Example -- NTILE(# of buckets) OVER (ORDER BY ranking_column) AS new_column_name SELECT customer_id , composite_score , NTILE ( 100 ) OVER ( ORDER BY composite_score ) AS percentile FROM customer_lead_score ; Example - get each quartile for each account_id SELECT account_id , occurred_at , standard_qty , NTILE ( 4 ) OVER ( PARTITION BY account_id ORDER BY standard_qty ) AS standard_quartile FROM orders ORDER BY account_id DESC","title":"Percentiles NTILE"},{"location":"7_sql_advanced_joins_performance_tuning/","text":"SQL Advanced JOINs and Performance Tuning Create fast-running queries with advanced joins Evaluate business questions Tune the performance of queries Create solutions for edge-cases FULL OUTER JOIN SELECT column_name ( s ) FROM Table_A FULL OUTER JOIN Table_B ON Table_A . column_name = Table_B . column_name ; RETURN ALL UNMATCHED ROWS SELECT column_names ( s ) FROM Table_A AS ta FULL OUTER JOIN Table_B AS tb ON ta . id = tb . id WHERE ta . id IS NULL OR tb . id IS NULL SELECT a . id AS accounts_id , sr . id AS sales_rep_id FROM accounts as a FULL OUTER JOIN sales_reps as sr ON a . sales_rep_id = sr . id WHERE a . id IS NULL OR sr . id IS NULL JOINs with Comparison Operators Pro Tip : If you recall from earlier lessons on joins, the join clause is evaluated before the where clause -- filtering in the join clause will eliminate rows before they are joined, while filtering in the WHERE clause will leave those rows in and produce some nulls. SELECT accounts . name as account_name , accounts . primary_poc as poc_name , sales_reps . name as sales_rep_name FROM accounts LEFT JOIN sales_reps ON accounts . sales_rep_id = sales_reps . id AND accounts . primary_poc < sales_reps . name Self JOINs SELECT o1 . id AS o1_id , o1 . account_id AS o1_account_id , o1 . occurred_at AS o1_occurred_at , o2 . id AS o2_id , o2 . account_id AS o2_account_id , o2 . occurred_at AS o2_occurred_at FROM orders o1 LEFT JOIN orders o2 ON o1 . account_id = o2 . account_id AND o2 . occurred_at > o1 . occurred_at AND o2 . occurred_at <= o1 . occurred_at + INTERVAL '28 days' ORDER BY o1 . account_id , o1 . occurred_at UNION The UNION operator is used to combine the result sets of 2 or more SELECT statements. It removes duplicate rows between the various SELECT statements. Each SELECT statement within the UNION must have the same number of fields in the result sets with similar data types. Typically, the use case for leveraging the UNION command in SQL is when a user wants to pull together distinct values of specified columns that are spread across multiple tables. For example, a chef wants to pull together the ingredients and respective aisle across three separate meals that are maintained within different tables. syntax there must be the same number of expressions in both SELECT statements corresponding expression myst have the same data type in the SELECT statements ___ProTip__ UNION remove duplicate rows SELECT * FROM web_events UNION SELECT * FROM web_events_2 UNION ALL does not remove duplicate rows SELECT * FROM web_events UNION ALL SELECT * FROM web_events_2 useful link on sql unions Perfomance tuning what are the things that affect performance Table Size Joins Aggregations Other users running queries concurrently on the DB DB software and optimization (e.g. POSTGRES is optimized different than REDSHIFT) LIMIT in a subquery if you can LIMIT happens afer the aggregations and group by so if you want to limit the table you should use a sub query This will not save time SELECT SUM ( poster_qty ) AS sum_poster_qty FROM orders WHERE occurred_at >= '2016-01-01' AND occurred_at < '2016-07-01' LIMIT 10 This will save time SELECT account_id , SUM ( poster_qty ) AS sum_poster_qty FROM ( SELECT * FROM orders LIMIT 10 ) sub WHERE occurred_at >= '2016-01-01' AND occurred_at < '2016-07-01' GROUP BY 1 Reduce the number of rows to join The second thing you can do is to make joins less complicated, that is, reduce the number of rows that need to be evaluated. It is better to reduce table sizes before joining them. This can be done using a sub query non performant SELECT accounts . name , COUNT ( * ) AS web_events FROM accounts JOIN web_events events ON events . account_id = accounts . id GROUP BY 1 ORDER BY 2 DESC performant SELECT a . name , sub . web_events FROM ( SELECT account . id , COUNT () AS web_events FROM web_events GROUP BY 1 ) sub JOIN accounts a ON a . id = sub . account_id ORDER BY 2 DESC Use EXPLAIN Adding the command EXPLAIN at the beginning of any query allows you to get a sense of how long it will take your query to run. it will output a query plan. The query plan will attach a cost to the query and the higher the cost, the longer the runtime. EXPLAIN is most useful to identify and modify those steps that are expensive EXPLAIN SELECT * FROM web_events WHERE occurred_at >= '2016-01-01' AND occurred_at < '2016-02-01' -- output of query plan Limit (cost=0.00..69.68 rows=100 width=23) -> Seq Scan on web_events (cost=0.00..195.09 rows=280 width=23) Filter: ((occurred_at >= '2016-01-01 00:00:00'::timestamp without time zone) AND (occurred_at < '2016-02-01 00:00:00'::timestamp without time zone)) EXPLAIN SELECT * FROM web_events WHERE occurred_at >= '2016-01-01' AND occurred_at < '2016-02-01' LIMIT 100","title":"SQL Advanced JOINS & Performance Tuning"},{"location":"7_sql_advanced_joins_performance_tuning/#sql-advanced-joins-and-performance-tuning","text":"Create fast-running queries with advanced joins Evaluate business questions Tune the performance of queries Create solutions for edge-cases","title":"SQL Advanced JOINs and Performance Tuning"},{"location":"7_sql_advanced_joins_performance_tuning/#full-outer-join","text":"SELECT column_name ( s ) FROM Table_A FULL OUTER JOIN Table_B ON Table_A . column_name = Table_B . column_name ;","title":"FULL OUTER JOIN"},{"location":"7_sql_advanced_joins_performance_tuning/#return-all-unmatched-rows","text":"SELECT column_names ( s ) FROM Table_A AS ta FULL OUTER JOIN Table_B AS tb ON ta . id = tb . id WHERE ta . id IS NULL OR tb . id IS NULL SELECT a . id AS accounts_id , sr . id AS sales_rep_id FROM accounts as a FULL OUTER JOIN sales_reps as sr ON a . sales_rep_id = sr . id WHERE a . id IS NULL OR sr . id IS NULL","title":"RETURN ALL UNMATCHED ROWS"},{"location":"7_sql_advanced_joins_performance_tuning/#joins-with-comparison-operators","text":"Pro Tip : If you recall from earlier lessons on joins, the join clause is evaluated before the where clause -- filtering in the join clause will eliminate rows before they are joined, while filtering in the WHERE clause will leave those rows in and produce some nulls. SELECT accounts . name as account_name , accounts . primary_poc as poc_name , sales_reps . name as sales_rep_name FROM accounts LEFT JOIN sales_reps ON accounts . sales_rep_id = sales_reps . id AND accounts . primary_poc < sales_reps . name","title":"JOINs with Comparison Operators"},{"location":"7_sql_advanced_joins_performance_tuning/#self-joins","text":"SELECT o1 . id AS o1_id , o1 . account_id AS o1_account_id , o1 . occurred_at AS o1_occurred_at , o2 . id AS o2_id , o2 . account_id AS o2_account_id , o2 . occurred_at AS o2_occurred_at FROM orders o1 LEFT JOIN orders o2 ON o1 . account_id = o2 . account_id AND o2 . occurred_at > o1 . occurred_at AND o2 . occurred_at <= o1 . occurred_at + INTERVAL '28 days' ORDER BY o1 . account_id , o1 . occurred_at","title":"Self JOINs"},{"location":"7_sql_advanced_joins_performance_tuning/#union","text":"The UNION operator is used to combine the result sets of 2 or more SELECT statements. It removes duplicate rows between the various SELECT statements. Each SELECT statement within the UNION must have the same number of fields in the result sets with similar data types. Typically, the use case for leveraging the UNION command in SQL is when a user wants to pull together distinct values of specified columns that are spread across multiple tables. For example, a chef wants to pull together the ingredients and respective aisle across three separate meals that are maintained within different tables. syntax there must be the same number of expressions in both SELECT statements corresponding expression myst have the same data type in the SELECT statements ___ProTip__ UNION remove duplicate rows SELECT * FROM web_events UNION SELECT * FROM web_events_2 UNION ALL does not remove duplicate rows SELECT * FROM web_events UNION ALL SELECT * FROM web_events_2 useful link on sql unions","title":"UNION"},{"location":"7_sql_advanced_joins_performance_tuning/#perfomance-tuning","text":"what are the things that affect performance Table Size Joins Aggregations Other users running queries concurrently on the DB DB software and optimization (e.g. POSTGRES is optimized different than REDSHIFT)","title":"Perfomance tuning"},{"location":"7_sql_advanced_joins_performance_tuning/#limit-in-a-subquery-if-you-can","text":"LIMIT happens afer the aggregations and group by so if you want to limit the table you should use a sub query This will not save time SELECT SUM ( poster_qty ) AS sum_poster_qty FROM orders WHERE occurred_at >= '2016-01-01' AND occurred_at < '2016-07-01' LIMIT 10 This will save time SELECT account_id , SUM ( poster_qty ) AS sum_poster_qty FROM ( SELECT * FROM orders LIMIT 10 ) sub WHERE occurred_at >= '2016-01-01' AND occurred_at < '2016-07-01' GROUP BY 1","title":"LIMIT in a subquery if you can"},{"location":"7_sql_advanced_joins_performance_tuning/#reduce-the-number-of-rows-to-join","text":"The second thing you can do is to make joins less complicated, that is, reduce the number of rows that need to be evaluated. It is better to reduce table sizes before joining them. This can be done using a sub query non performant SELECT accounts . name , COUNT ( * ) AS web_events FROM accounts JOIN web_events events ON events . account_id = accounts . id GROUP BY 1 ORDER BY 2 DESC performant SELECT a . name , sub . web_events FROM ( SELECT account . id , COUNT () AS web_events FROM web_events GROUP BY 1 ) sub JOIN accounts a ON a . id = sub . account_id ORDER BY 2 DESC","title":"Reduce the number of rows to join"},{"location":"7_sql_advanced_joins_performance_tuning/#use-explain","text":"Adding the command EXPLAIN at the beginning of any query allows you to get a sense of how long it will take your query to run. it will output a query plan. The query plan will attach a cost to the query and the higher the cost, the longer the runtime. EXPLAIN is most useful to identify and modify those steps that are expensive EXPLAIN SELECT * FROM web_events WHERE occurred_at >= '2016-01-01' AND occurred_at < '2016-02-01' -- output of query plan Limit (cost=0.00..69.68 rows=100 width=23) -> Seq Scan on web_events (cost=0.00..195.09 rows=280 width=23) Filter: ((occurred_at >= '2016-01-01 00:00:00'::timestamp without time zone) AND (occurred_at < '2016-02-01 00:00:00'::timestamp without time zone)) EXPLAIN SELECT * FROM web_events WHERE occurred_at >= '2016-01-01' AND occurred_at < '2016-02-01' LIMIT 100","title":"Use EXPLAIN"},{"location":"8_useful_links/","text":"Useful Links Links for SQL practice HackerRank ModeAnalytics Analytics Vidhya","title":"Useful Links"},{"location":"8_useful_links/#useful-links","text":"","title":"Useful Links"},{"location":"8_useful_links/#links-for-sql-practice","text":"HackerRank ModeAnalytics Analytics Vidhya","title":"Links for SQL practice"}]}